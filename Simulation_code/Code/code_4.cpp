#include <cstdio>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <time.h>
#include <cstdlib>
#include <ctime>
#include <iomanip>
#include <string>
#include <string.h>
#include <list>
#include <algorithm>
#include <random> ///partho
#include <functional>
#include <math.h>
#include <sys/time.h>
#include <tuple>
#include "functions.hpp"
#include "bList.hpp"
#include "TList.hpp"
#include "DPList.hpp"
#include "params.hpp"
#include "neighborList.hpp"
#include "CBH_enzyme.hpp"
#include "tuple_hash.hpp"
#include <chrono>
#include <cmath>
#include <unordered_map>
#include <omp.h>

using   namespace  std;
using std::ifstream;
using std::ofstream;
using std::ios;
using namespace std::chrono;


//Declare running function
//Runs the gillespie algorithm. See below main() for more details
//double run(bool verbose, bool randomSeed, bool vid, bool heatmap_bool, bool xyl_or_mlg, long int seed48, const int current_run, int& outputBoundary, vector<DPList>& DP_distrib, params& par);
double run(bool verbose, bool randomSeed, bool vid, bool heatmap_bool, long int seed48, const int current_run, int& outputBoundary, vector<DPList>& DP_distrib, params& par);


//======================================================================================
//================== Other functions are defined in functions.cpp  =====================
//======================================================================================






//===========================================================================================================================================================
//================================================================= MAIN ====================================================================================
//===========================================================================================================================================================
int main(int argc, char *argv[]){

				//======================================================================================
				//=== Declaration of variables related to how the code will run (e.g. types of Output)==
				//======================================================================================



    int outputBoundary = 0; //index up to which the mean values for glc, cellobiose and time will be output for DP_distrib
    //int current_run = 1;//this counts the number of done runs in while loop


    long int seed48 = 161892329918;//seed of random generator if it is fixed

    double mean = 0;//Average saccharification yield over all runs



    //========================== Boolean values connected to keyboard input ==========================


    bool multiOutput = true; // If this is set to 1, an output file will be generated for every outputlimiter-th run
    bool vid = false; // If this is set to 1, files for a 3D video of the degradation process will be created. Beware, this takes a while!
    bool verbose = false;//If this is set to 1, an increased number of progress messages will be printed
    bool randomSeed = true;//If this is set to 1, the seed of the random generators will vary. Otherwise it will stay the same during each run()
    bool enzyme_timer = false;//If this is set to 1, the time each digestion take is tracked and printed at the end of the run
    bool heatmap_bool = false;//If this is set to 1, a (potentially large) file will be generated, which contains the degree-of-polymerization(DP) distribution during each simulation step
    bool output_bool = true;//If this is set to 0, no output will be generated by the code. Mainly for debugging purposes
    bool suffix_bool = true;//If this is set to true, the first command line argument will be used as part of the output filenames.
    bool print_polys = false;//If this is set to true, the positions of all remaining bonds (if there are any) will be printed to file after a finished simulation
    bool print_ends_blocked = false;//If this is set to true, the average number of blocked polymer ends by CBH enzymes will be tracked and printed to file
    bool print_CBH_positions = false;//If this is set to true, the positions of all attached CBH enzymes will be tracked
    bool toy_model = false;//If this is set to true, every bond will be accessible from the beginning. This resembles the situation of all polymers freely floating in space
    bool print_time = false;//If this is set to true, the computation time of each run will be printed to a file

    int num_workers = 1;  // Sets the maximum amount of cores used by this program



  	//============================= Check command line arguments ====================================================
    if(argc > 1){
        for(int i=0;i<argc;i++){
            cout << argv[i] << endl;
            if(! strcmp(argv[i], "-verbose")){
                cout << "verbose" << endl;
                verbose = 1;
            }
            else if(! strcmp(argv[i], "-fixed_seed")){
                cout << "Fixed seed" << endl;
                randomSeed = 0;
            }
            else if(! strcmp(argv[i], "-vid")){
                cout << "vid" << endl;
                vid = 1;
            }
            else if(! strcmp(argv[i], "-timer")){
            	cout << "Timer for enzyme functions is on" << endl;
            	enzyme_timer = 1;
            }
            else if(! strcmp(argv[i], "-heatmap")){
                cout << "Data for heatmap will be generated" << endl;
                heatmap_bool = 1;
            }
            else if(! strcmp(argv[i], "-suppress_output")){
                cout << "No output will be generated" << endl;
                output_bool = false;
            }
            else if(! strcmp(argv[i], "-no_suffix")){
                cout << "Files will have no specific ending" << endl;
                suffix_bool = false;
            }
            else if(! strcmp(argv[i], "-parallel")){
                cout << "Parallel option set. Using " << argv[i+1] << " cores." << endl;
                num_workers = stoi(argv[i+1]);
            }
            else if(! strcmp(argv[i], "-print_polys")){
                cout << "Remaining poly bonds will be printed to file." << endl;
                print_polys = true;
            }
            else if(! strcmp(argv[i], "-print_ends_blocked")){
                cout << "Average ends blocked by CBH will be tracked and printed to file." << endl;
                print_ends_blocked = true;
            }
            else if(! strcmp(argv[i], "-print_CBH_positions")){
                cout << "Average ends blocked by CBH will be tracked and printed to file." << endl;
                print_CBH_positions = true;
            }
            else if(! strcmp(argv[i], "-toy_model")){
                cout << "Using toy model, i.e. no blocking of bonds" << endl;
                toy_model = true;
            }
            else if(! strcmp(argv[i], "-print_time")){
                cout << "Printing computation time to file" << endl;
                print_time = true;
            }

        }
    }

    omp_set_num_threads(num_workers);//Set max number of cores to be used. Default value is 1



    //==================================================================================================
    //TODO: FOR A QUICK WAY OF PARALLELIZING THIS CODE, THE INPUT FILE READING HAD TO BE MOVED INTO THE LOOP.
    //BUT WE NEED THE PARAMETER Nruns IN ORDER TO KNOW, HOW LONG THE LOOP SHOULD BE
    //==================================================================================================
    int Nruns = 0;//Number of simulation runs
    double place_holder;//place_holder variable for using ifstream
    string myline;//Storage buffer for simulation_parameters

    std::string paramFileDir = "Params/";//Directory in which the input files are stored.
    std::string simuParams = "simulation_parameters";//This file defines the simulation time and parameters related to the main structure of the fibril
    ifstream file0(paramFileDir + simuParams + ".txt");
    myline.clear();
    if(file0)
    {
        getline(file0,myline);
        istringstream in(myline);
        in >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> place_holder >> Nruns >> place_holder >> place_holder;
    }
    else{
        cout << "simulation_parameters.txt does not exist in the folder Params/ . Exiting." << endl;
        exit(1);
    }





	//========================================================================
    //========================== Gillespie run(s) ============================
    //========================================================================

    cout << "Nruns = " << Nruns << endl;
    #pragma omp parallel for
    for(int current_run = 1; current_run < Nruns+1;current_run++){
//    while( current_run < par.Nruns+1){//This runs as often as


        string line;//For reading input files
        params par;//This is where most parameters and variables are stored, in order to make them easily accessible from within functions. See structs.hpp
        par.initialize();//Initialize object par

        //Provide object par with those values which have already been specified
        par.verbose = verbose;
        par.DP_print_Freq = 1;//Determines, how often the DP-distribution of the system is screened. If set to 1e2, this is done every 100th step
        par.enzyme_timer = enzyme_timer;//Boolean value which checks whether the enzyme digestion functions are timed. In development
        par.print_polys = print_polys;
        par.print_ends_blocked = print_ends_blocked;
        par.print_CBH_positions = print_CBH_positions;
        par.toy_model = toy_model;
        par.print_time = print_time;

        // Check whether the initial configuration parameters should be taken from a file other than "initial_configuration_parameters.txt"

        if(argc > 1 and suffix_bool == true){
            par.initConfigParams = "initial_configuration_parameters_" + string(argv[1]) + ".txt";
        }



    //=========================================================================================//
    //============================== Read input parameters files ==============================//
    //=========================================================================================//


    //============================== Read simulation parameters ===============================//

        ifstream file0(par.paramFileDir + par.simuParams + ".txt");

        line.clear();

        if(file0)
        {
            getline(file0,line);
            istringstream in(line);
            in >> par.T >> par.Transient >> par.Nbr_picts >> par.max_time
            >> par.pict_3D_Freq >> par.N_layers >> par.mode_hemi
            >> par.mode_lign >> par.mode_inhib >> par.mode_lignin_glue
            >> par.mode_enzyme_size
            >> par.Nruns >> par.mu_lignin_covering >> par.sigma_lignin_covering;
        }
        else{
            cout << "simulation_parameters.txt does not exist in the folder Params/ . Exiting." << endl;
            exit(1);
        }

        if(vid == true or print_CBH_positions == true){
            cout << "pict_3D_Freq = " << par.pict_3D_Freq << endl;
        }
        if(par.T + par.Transient <= 0){
            cout << "The sum of T and Transient must be greater than 0. Please correct this in simulation_parameters.txt. Aborting." << endl;
            exit(1);
        }
        if(par.Nbr_picts < 0){
            cout << "Nbr_picts must be 0 or greater. Please correct this in simulation_parameters.txt. Aborting." << endl;
            exit(1);
        }
        if(par.max_time <= 0){
            cout << "max_time must be greater than 0. Please correct this in simulation_parameters.txt. Aborting." << endl;
            exit(1);
        }



        par.V_enzyme = 4.*M_PI*par.enzyme_radius*par.enzyme_radius*par.enzyme_radius/3.;


        // ====================== Check outputBoundary
        if(outputBoundary == 0)
            outputBoundary = par.Nbr_picts;






        //==================================== Read initial configuration parameters =========================



        ifstream file2(par.paramFileDir + par.initConfigParams);

        line.clear();
        if(file2)
        {
            getline(file2,line);
            istringstream in(line);
            // in >> par.mode_code >> par.init_EG >> par.init_CBH >> par.init_BGL >> par.init_XYL >> par.length_fibril >> par.xyl_or_mlg >> par.pct_xyl >> par.pct_cellu_uns>> par.pct_hemi_uns >> par.pct_lign_uns >> par.pct_acetyl_hemi >> par.pct_crystalline_cellu >> par.pct_crystalline_hemi >> par.dfct_size >> par.N_amor_core >> par.r_monomer;  // partho_added paramter for small amount of amorphous core surrounded by cellulose
            
            
            in >> par.mode_code >> par.pct_EG >> par.pct_CBH >> par.pct_BGL >> par.pct_XYLA >> par.N_enz_total >> par.length_fibril >> par.xyl_or_mlg >> par.pct_xyl >> par.pct_cellu_uns >> par.pct_hemi_uns >> par.pct_lign_uns >> par.pct_acetyl_hemi >> par.pct_crystalline_cellu >> par.pct_crystalline_hemi >> par.dfct_size >> par.N_amor_core >> par.r_monomer; // partho added params for varying enzyme coctail composition and params for defects in crystalline cellu core 
            
            par.init_EG = (int)(par.N_enz_total * (par.pct_EG/(par.pct_EG + par.pct_CBH + par.pct_BGL + par.pct_XYLA)) + 0.5);
            par.init_CBH = (int)(par.N_enz_total * (par.pct_CBH/(par.pct_EG + par.pct_CBH + par.pct_BGL + par.pct_XYLA)) + 0.5);
            par.init_BGL = (int)(par.N_enz_total * (par.pct_BGL/(par.pct_EG + par.pct_CBH + par.pct_BGL + par.pct_XYLA)) + 0.5);            
            par.init_XYL = (int)(par.N_enz_total * (par.pct_XYLA/(par.pct_EG + par.pct_CBH + par.pct_BGL + par.pct_XYLA)) + 0.5);
            
            
            if(par.verbose == true){
                cout << "initial configutation paramters input" << endl;
                cout << par.mode_code << "\t" << par.pct_EG << "\t" << par.pct_CBH << "\t" << par.pct_BGL << "\t" << par.pct_XYLA << "\t" << par.N_enz_total << "\t" << par.length_fibril << "\t" << par.xyl_or_mlg << "\t" << par.pct_xyl << "\t" << par.pct_cellu_uns<< "\t" << par.pct_hemi_uns << "\t" << par.pct_lign_uns << "\t" << par.pct_acetyl_hemi << "\t" << par.pct_crystalline_cellu << "\t" << par.pct_crystalline_hemi << "\t" << par.dfct_size << "\t" << par.N_amor_core << "\t" << par.r_monomer << endl;
                cout << "Number of enzyme molecules (EG : CBH : BGl : XYL)- \t" << par.init_EG << "\t" << par.init_CBH << "\t" << par.init_BGL << "\t" << par.init_XYL << endl;
            }


            for(int i=0;i<par.init_CBH;i++)
                par.CBH_enzymes.push_back(CBH_enzyme());
            par.N_free_CBH = par.init_CBH;
        }
        else{
            cout << par.initConfigParams + " does not exist. Exiting." << endl;
            exit(1);
        }


    //============================== Check whether there are problems with the configuration parameters ===============================//

        if(par.length_fibril <= 0){
            cout << "=============================================================================================" << endl;
            cout << "Length of fibril is 0 or negative. Please Change this in ’initial_configuration_parameters.txt’" << endl;
            cout << "=============================================================================================" << endl;
            exit(1);
        }
        if(par.init_EG <= 0 and par.init_CBH <= 0 and par.init_BGL <= 0 and par.init_XYL <= 0){
            cout << "=============================================================================================" << endl;
            cout << "No enzymes in system, or negative concentrations. Nothing will be digested. Please adjust initial enzyme concentrations in ’initial_configuration_parameters.txt’" << endl;
            cout << "=============================================================================================" << endl;
            exit(1);
        }

        if( par.pct_cellu_uns > 1 or par.pct_lign_uns > 1 or par.pct_hemi_uns > 1 or par.pct_xyl > 1 or par.pct_acetyl_hemi > 1 or par.pct_cellu_uns < 0 or par.pct_lign_uns < 0 or par.pct_hemi_uns < 0 or par.pct_xyl < 0 or par.pct_acetyl_hemi < 0){
            cout << "=============================================================================================" << endl;
            cout << "One or more of the percentages in ’initial_configuration_parameters.txt’ is greater than 1 or less than 0. Please correct this and restart." << endl;
            cout << "=============================================================================================" << endl;
            exit(1);
        }

        if(verbose == true){
            cout << "Length of each fibril: " << par.length_fibril << endl;
        }



        //==================================== Read kinetic parameters ==================================


        ifstream file3(par.paramFileDir + par.kinParams + ".txt");
        line.clear();
        if(file3)
        {
            getline(file3,line);
            istringstream in(line);
//            in >> par.k1 >> par.k2 >> par.k3 >> par.k4 >> par.lignols_blocked_per_enzyme >> par.k6 >> par.inhib_cellobiose_EG >> par.inhib_cellobiose_CBH >> par.inhib_glucose_BGL >> par.crystal_modifier_cellu >> par.crystal_modifier_hemi;
            
            
            
//            in >> par.k1 >> par.k2 >> par.k3 >> par.k4 >> par.lignols_blocked_per_enzyme >> par.k6 >> par.inhib_cellobiose_EG >> par.inhib_cellobiose_CBH >> par.inhib_glucose_EG >> par.inhib_glucose_CBH >> par.inhib_glucose_BGL >> par.crystal_modifier_cellu >> par.crystal_modifier_hemi >> par.enzyme_radius;     //partho : added extra inhbition parameters for glucose on EG and CBH // Added enzyme size in kinetic params to allow fitting

            
            // Partho added Michaelis-Menten enzyme parameters

            in >> par.Kcat_EG >> par.Km_EG >> par.k2 >> par.Kcat_BGL >> par.Km_BGL >> par.Kcat_XYL >> par.Km_XYL >> par.lignols_blocked_per_enzyme >> par.Kcat_CBH >> par.Km_CBH >> par.inhib_cellobiose_EG >> par.inhib_cellobiose_CBH >> par.inhib_glucose_EG >> par.inhib_glucose_CBH >> par.inhib_glucose_BGL >> par.crystal_modifier_cellu >> par.crystal_modifier_hemi >> par.enzyme_radius;

            
            
            
            
            
            
//            in >> par.k1 >> par.k2 >> par.k3 >> par.k4 >> par.k5 >> par.k6 >> par.inhib_cellobiose_EG >> par.inhib_cellobiose_CBH >> par.inhib_glucose_BGL >> par.crystal_modifier_cellu >> par.crystal_modifier_hemi;
            par.k5 = 5.*(par.k1+par.k3+par.k6)/4.;
            if(par.lignols_blocked_per_enzyme <= 0){
                par.lignols_blocked_per_enzyme = 1;
            }

        }
        else{
        cout << "kinetic_parameters.txt does not exist in the folder Params/ . Exiting." << endl;
        exit(1);
        }
        if(par.k1 < 0){
            cout << "Please enter a non-negative k1 in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.k2 < 0){
            cout << "Please enter a non-negative k2 in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.k3 < 0){
            cout << "Please enter a non-negative k3 in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.k4 < 0){
            cout << "Please enter a non-negative k4 in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.inhib_cellobiose_EG < 0){
            cout << "Please enter a non-negative inhib_cellobiose_EG in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.inhib_cellobiose_CBH < 0){
            cout << "Please enter a non-negative inhib_cellobiose_CBH in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.inhib_glucose_EG < 0){
            cout << "Please enter a non-negative inhib_glucose_EG in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.inhib_glucose_CBH < 0){
            cout << "Please enter a non-negative inhib_glucose_CBH in the file kinetic_parameters.txt" << endl;
            exit(1);
        }
        if(par.inhib_glucose_BGL < 0){
            cout << "Please enter a non-negative inhib_glucose_BGL in the file kinetic_parameters.txt" << endl;
            exit(1);
        }

        //========================= DONE READING INPUT FILES =======================





        //======================== Build vector for keeping track of DP distribution

        vector<DPList> DP_distrib;


        cout << "Simu and seed number " << current_run << endl;



        //=========================================================================================================================================
        //================= Here the run() function is called an the Gillespie algorithm actually takes place ===================================
		//=========================================================================================================================================
//        mean += (run(verbose,randomSeed,vid,heatmap_bool, xyl_or_mlg, seed48, current_run, outputBoundary, DP_distrib, par))/double(par.Nruns);
	    mean += (run(verbose,randomSeed,vid,heatmap_bool, seed48, current_run, outputBoundary, DP_distrib, par))/double(par.Nruns);


        cout << "====================================" << endl;
        cout << "Returned from run()" << endl;
        cout << "\n" << endl;




        //=====================================================================================================================
        //======================================== Generate output files=======================================================
		//=====================================================================================================================


        //OPEN ALL FILES
      	if(output_bool == true){
		    if(par.time_mean.size() > 0){
    		    if(argc > 1 and suffix_bool == true){
    		    	par.output_file = par.outputFileDir + "saccharification/saccharification_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
    		    }
    		    else{
    		    	par.output_file = par.outputFileDir + "saccharification/saccharification_" + to_string(current_run) + ".txt";
    		    }
    		    ofstream meanFile(par.output_file);
    		    if(argc > 1 and suffix_bool == true){
    		    	par.output_file = par.outputFileDir + "enzyme_concentration/enzyme_concentration_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
    		    }
    		    else{
    		    	par.output_file = par.outputFileDir + "enzyme_concentration/enzyme_concentration_" + to_string(current_run) + ".txt";
    		    }
    		    ofstream enzyme_conc_File(par.output_file);
    		    if(argc > 1 and suffix_bool == true){
    		    	par.output_file = par.outputFileDir + "enzyme_concentration/enzymes_glued_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
    		    }
    		    else{
    		    	par.output_file = par.outputFileDir + "enzyme_concentration/enzymes_glued_" + to_string(current_run) + ".txt";
    		    }
    		    ofstream lignin_glued_File(par.output_file);
    		    if(argc > 1 and suffix_bool == true){
    		    	par.output_file = par.outputFileDir + "enzyme_activity/enzyme_activity_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
    		    }
    		    else{
    		    	par.output_file = par.outputFileDir + "enzyme_activity/enzyme_activity_" + to_string(current_run) + ".txt";
    		    }
    		    ofstream EnzymeActivityFile(par.output_file);
                if(argc > 1 and suffix_bool == true){
                    par.output_file = par.outputFileDir + "enzyme_activity/ends_blocked_by_CBH_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
                }
                else{
                    par.output_file = par.outputFileDir + "enzyme_activity/ends_blocked_by_CBH_" + to_string(current_run) + ".txt";
                }
                ofstream EndsBlockedFile(par.output_file);



    		    //WRITE VALUES
    		    for(int i=0;i<par.time_mean.size();i++){
    		        if(i<par.amount_glc_mean.size())
    		            meanFile << par.time_mean[i] << "\t" << par.amount_glc_mean[i] << "\t" << par.amount_cellobiose_mean[i] << "\t" << par.amount_xylose_mean[i] << endl;
						enzyme_conc_File << par.time_mean[i] << "\t" << par.EG_conc_mean[i] << "\t" << par.CBH_conc_mean[i] << "\t" << par.BGL_conc_mean[i] << "\t" << par.XYL_conc_mean[i] << endl;
						lignin_glued_File << par.time_mean[i] << "\t" << par.enzymes_glued[i] << endl;
						EnzymeActivityFile << par.time_mean[i] << "\t" << par.EG_activity[i] << "\t" << par.CBH_activity[i] << "\t" << par.BGL_activity[i] << "\t" << par.XYL_activity[i] << "\t" << par.lign_activity[i] << endl;
                        if(print_ends_blocked == true){
                            EndsBlockedFile << par.time_mean[i] << "\t" << par.average_ends_occupied_by_CBH[i] <<  "\t" << par.number_of_attached_CBH[i] << endl;
                        }
    		    }
    		    meanFile.close();
    		    enzyme_conc_File.close();
    		    lignin_glued_File.close();
    		    EnzymeActivityFile.close();
                EndsBlockedFile.close();

    		    if(argc > 1 and suffix_bool == true){
    		    	par.output_file = par.outputFileDir + "enzyme_fraction/enzyme_fraction_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
    		    }
    		    else{
    		    	par.output_file = par.outputFileDir + "enzyme_fraction_/enzyme_fraction_" + to_string(current_run) + ".txt";
    		    }
    		    ofstream EnzymeFractionFile(par.output_file);

	            if(par.timestamp.size()>0){
	                for(int i=0;i<par.timestamp.size();i++){
	                    EnzymeFractionFile << par.timestamp[i] << "\t" << par.EG_fraction[i] << "\t" << par.CBH_fraction[i] << "\t" << par.BGL_fraction[i] << "\t" << par.XYL_fraction[i] << "\t" << par.lign_fraction[i] << endl;
	                }
	                EnzymeFractionFile.close();

		        if(argc > 1 and suffix_bool == true){
		        	par.output_file = par.outputFileDir + "Nbr_reactions/Nbr_reactions_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";

		        }
		        else{
					par.output_file = par.outputFileDir + "Nbr_reactions/Nbr_reactions_" + to_string(current_run) + ".txt";
		        }


			    ofstream reaction_number(par.output_file);
			    for(int i=0;i<par.Nbr_reactions.size();i++){
			    	reaction_number << par.time_mean[i] << "\t" << par.Nbr_reactions[i] << endl;
			    }
			    reaction_number.close();

	            }
	            if(heatmap_bool == 1){
	                if(DP_distrib.size()>0){
                        if(argc > 1 and suffix_bool == true){
                        	par.output_file = par.outputFileDir + "DP_distrib/DP_distrib_" + string(argv[1]) + "_" + to_string(current_run) + ".txt";
                        }
                        else{
                        	par.output_file = par.outputFileDir + "DP_distrib/DP_distrib_" + to_string(current_run) + ".txt";
                        }
	                    cout << "Size of DP_distrib: " << DP_distrib.size()*DP_distrib[0].DP.size() << endl;
	                    ofstream DPFile(par.output_file);
	                    for(int i=0; i<DP_distrib.size(); i++){
	                        for(int j=0; j<DP_distrib[i].DP.size();j++){
	                            DPFile << DP_distrib[i].real_time << "\t" << j << "\t" << DP_distrib[i].DP[j] << endl;
	                        }
	                    }
	                    DPFile.close();
	                }
	            }
          	}



        //=====================================================================================================================
        //=================================== Clear output data containers for next run========================================
		//=====================================================================================================================

		    par.time_mean.clear();
		    par.amount_glc_mean.clear();
		    par.amount_cellobiose_mean.clear();
		    par.amount_xylose_mean.clear();
            par.EG_conc_mean.clear();
            par.CBH_conc_mean.clear();
            par.BGL_conc_mean.clear();
            par.XYL_conc_mean.clear();
		    par.EG_activity.clear();
		    par.CBH_activity.clear();
		    par.BGL_activity.clear();
		    par.XYL_activity.clear();
            par.lign_activity.clear();
            par.EG_fraction.clear();
            par.CBH_fraction.clear();
            par.BGL_fraction.clear();
            par.XYL_fraction.clear();
            par.lign_fraction.clear();
            par.timestamp.clear();
            par.enzymes_glued.clear();
            par.Nbr_reactions.clear();
            par.CBH_enzymes.clear();
            par.average_ends_occupied_by_CBH.clear();
            for(int i=0;i<par.init_CBH;i++)
                par.CBH_enzymes.push_back(CBH_enzyme());
            par.N_free_CBH = par.init_CBH;
            par.free_poly_ends.clear();

            if(heatmap_bool == 1)
                DP_distrib.clear();
		}
	    else{
	    	cout << "No data in mean_file" << endl;
	    }
        cout << "====================================" << endl;

    }



    //===================== Print mean values to file ====================





    cout << "Mean glc produced: " << mean << endl;
//    cout << "Mean lignin percentage: " << mean << endl;



    cout << "END OF main()!!!" << endl;
    return 0;
//===========================================================================================================================================================
//=================================================================== END OF MAIN ===========================================================================
//===========================================================================================================================================================
}


//===========================================================================================================================================================
//=================================================== THIS RUNS THE GILLESPIE ALGORITHM FOR A SINGLE SIMULATION =============================================
//===========================================================================================================================================================

double run(bool verbose, bool randomSeed, bool vid, bool heatmap_bool, long int seed48, const int current_run, int& outputBoundary, vector<DPList>& DP_distrib, params& par){



		//======================================================================================
		//====== Declaration of variables which will not be contained in the "params" struct====
		//======================================================================================

    double x  = 0.;//Used to assign x-coordinates of polymers
    double y = 0.;//Used to assign y-coordinates of polymers
    int z = 0.;//Used to assign z-coordinates of bonds within polymers
    double x_selected = 0.;//Used during gillespie algorithm to determine the position of the bond to be digested
    double y_selected = 0.;//Used during gillespie algorithm to determine the position of the bond to be digested
    int z_selected = 0.;//Used during gillespie algorithm to determine the position of the bond to be digested

    int nbr_poly_cellu = 0;//Number of cellulose polymers in the system
    int nbr_poly_hemi = 0;//Number of hemicellulose polymers in the system
    int nbr_poly_lign = 0;//Number of lignin polymers in the system

    int nbr_bd_hemi;//Initial number of bonds in hemicellulose

    int nbr_Glc_pdt = 0;//Amount of glucose released from microfibil
    int nbr_xyl_pdt = 0;//Amount of xylose released from the microfibril
    int nbr_cellobiose = 0;//Amount of cellobiose in the system

    int nbr_pict_taken = 0;//Number of snapshots taken of the system during the Gillespie loop
    int nbr_poly_overall = 0;//Overall number of polymers in system

    int counter = 0;//Used for filling the microfibril shell with hemicellulose and lignin
    int x1 = 0;//Used for filling the microfibril shell with hemicellulose and lignin
    int x2 = 0;//Used for filling the microfibril shell with hemicellulose and lignin

    int nbr_CBH_pictures = 0;

    int bond_selected = 0;//Bond selected at gillespie step
    int action_mu1 = 0;//Enzymatic action at gillespie step
    int substrate = 0;//Substrate of reaction at gillespie step
    int poly_selected = 0;//Selected polymer at gillespie step
    int cut_applicate = 0;//z coordinate of selected bond at gillespie step
    int table_selected = 0;//Selected reaction table at gillespie step (this number should always be the same as poly_selected)
    int indic_cut = 0;//Value is 0 if the cut is at the head of the polymer, 1 if the cut is at the tip of thepolymer

    int THRESHOLD = 0;//Checks whether time > Transient
    int mu1;//Used for selecting reaction in specific reaction table during gillespie step

    int min_x = 0;//These four are used to check the positions of the polymers within the fibril during the initialization phase and adjust their status accordingly
    int max_x = 0;
    int min_y = 0;
    int max_y = 0;

    int printFreq = 1e3; //Defines, how often a progress message is printed during gillespie loop
    //int pict_3D_Freq = 1e0; //Defines, how often a 3D structure picture is taken during gillespie loop
    int enzyme_activity_Freq = 1;//Defines, how often all reaction tables are screened for the distribution of reactions among enzyme types


    int glucoseOverall = 0;//Overall glucose in the system, including that which is bound inside the microfibril
    int xyloseOverall = 0;//Overall xylose in the system, including that which is bound inside the microfibril

    int count_glc;//For distribution of xylose and glucose in hemicellulose polymers
    int count_xyl;


    int count_EG = 0;//Counts the number of times EG acts during the simulation
    int count_CBH = 0;//Counts the number of times CBH acts during the simulation
    int count_BGL = 0;//Counts the number of times BGL acts during the simulation
	int count_xylanase = 0;//Counts the number of times XYL acts during the simulation
    int count_lignin_glue = 0;//Counts the number of times the lignin glueing effect acts during the simulation


	int nbr_molecs_overall = 0;
    int len_polyLoopStart = 0; //Length of polymer before digest
    int reactionsOverall = 0;//Number of reactions within all reaction tables
    int glcBefore = 0;//Glucose in system (in cellulose + in hemicellulose + released) before a digestion step. This is used in order to check whether glucose is created from nothing or lost
    int glcCelluBefore = 0;//Glucose contained in cellulose before a digestion step. This is used in order to check whether glucose is created from nothing or lost
    int glcHemiBefore = 0;//Glucose contained in hemicellulose before a digestion step. This is used in order to check whether glucose is created from nothing or lost
    int lignolBefore = 0;//Lignin units contained in system. These should only change during the initialization phase, since there is nothing in the mode which degrades lignin
    int DP_index = 0;//Index of DP output vector
    int DP_len_index = 0;//Index whose entry is to be increased by one during DP_distribution check

    int Nbr_glc_in_cellu;//Number of glucose molecules initially in the microfibril
    int Nbr_xyl_in_hemi = 0;//Number of xylose molecules initially in the microfibril (calculated depending on percentages of cellulose,hemicellulose and lignin)
    int Nbr_lignol_in_lign = 0;//Number of monolignol molecules initially in the microfibril (calculated depending on percentages of cellulose,hemicellulose and lignin)

    double propensite = 0.;//Used to assign propensity values to the reactions in the gillespie algorithm
    double a0 = 0.;//Sum of propensities of all reactions in system
    double tau = 0.;//Gillespie timestep size
    double reaction_table_sample = 0.;//Used to choose reaction at the beginning of each gillespie step

    double time_Transient = 0.;
    double t0 = 0.;//Gillespie step count

    par.N_enzymes_glued = 0;//Number of enzymes glued by lignin
    double free_CBH_before = 0.;//Tracks the number of free CBH enzymes at the beginning of each gillespie step
    double reaction_count = 0.;//Tracks the number of reactions performed

    double dx = 0.;//These three are used for calculating the absolute distance between two points in the system
    double dy = 0.;
    double dz = 0.;


    //================================= Values used for estimation of system volume. Not used within Gillespie algorithm =====================
    double d_fibril = 3e-9;//diameter of a microfibril in m(rough value from literature)
    double d_glc = 1e-9;//diameter of a glucose molecule in m (rough value)
    double m_glc = 0.180156/(6.022e23); //2.991e-22 ;//mass of a glucose molecule in kg (from wikipedia; molar mass M = 180.156 g/mol); MASS OF HYDROGEN LOST IN BONDS NEEDS TO BE SUBTRACTED
    double m_dry = 1e-6;//Dry weight of saccharification experiment sample in kg
    double m_hydrogen = 1.67e-27;//Mass of a proton (here to be set equal to the mass of a hydrogen atom)
    double V_solution = 1e-7; //Volume of saccharification experiment sample in m^3
    double m_fibril = 0.;//Mass of the microfibril
    double V_fibril = 0.;//Volume of the microfibril
    double V_System = 0.;//Volume of the entire system, with the microfibril in solution




    bool error_bool = false;//This is set to true if an error is detected at any point in a sub function. If this happens, the code aborts
    bool adjust_cellu = false; //This is set to true if the cellulose percentage is below the minimum value achievable without shortening the cellulose core. The shortening is then carried out

    string line;//For reading input files

    vector<double> chem_entities;//This contains the amounts of enzymes EG, CBH, BGL, and XYL available in the system, as well as the number of lignin monomers

    vector<vector<double>> x_pos_hemi, y_pos_hemi, x_pos_lign, y_pos_lign;//These contain the positions of POSSIBLE ANCHORING for hemicellulose and lignin at each layer
    vector<double> vect_hemi_x, vect_hemi_y, vect_lign_x, vect_lign_y;//These contain the positions on the section where hemicellulose and lignin can anchor

    vector<bList> cellu;//Container for all cellulose polymers
    vector<bList> hemi;//Container for all hemicellulose polymers
    vector<bList> lign;//Container for all lignin polymers

    vector<TList> Table_cellu;//Container for all reaction tables for cellulose
    vector<TList> Table_hemi;//Container for all reaction tables for hemicellulose
    TList Table_lign;//reaction table for lignin. Used for function lignin_glue()



    //========================= Variables for tracking the computation time taken for executing funtions or parts of the code ================

    vector<double> time_EG;//Stores the computation time each EG-digestions takes
    vector<double> time_CBH;//Stores the computation time each CBH-digestions takes
    vector<double> time_BGL;//Stores the computation time each BGL-digestions takes
    vector<double> time_XYL;//Stores the computation time each XYL-digestions takes
    vector<double> time_find_reaction;//Stores the computation time it takes to find a reaction during each gillespie step
    vector<double> time_per_gillespie_step;//Stores the computation time each gillespie step takes


    vector<int> nbr_reactions;//Tracks the overall number of reactions contained in all reaction tables

    std::tuple<double,double,int> neighbor_key; //Used as keys for the following neighborList maps
    double neighbor_check_radius = par.r_monomer;//Radius for the sphere investigated around each bond within bond_neighbors_cellu and bond_neeighbors_hemi
    if(par.mode_enzyme_size == 1){
     neighbor_check_radius = par.enzyme_radius;
    }
    unordered_map<std::tuple<double,double,int>,neighborList> bond_neighbors_cellu;//Stores the neighbors of each cellu bond as well as the occupied volume within a sphere of choosable radius around the respective bond
    unordered_map<std::tuple<double,double,int>,neighborList> bond_neighbors_hemi;//Stores the neighbors of each hemi bond as well as the occupied volume within a sphere of choosable radius around the respective bond


    auto t_start_of_run = high_resolution_clock::now();//For measuring the overall time taken by the gillespie run

    //Parameters related to measuring the computation time of each enzyme digestion function
 	auto t_start = high_resolution_clock::now();
	auto t_end = high_resolution_clock::now();
 	auto t_start_gillespie = high_resolution_clock::now();
	auto t_end_gillespie = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(t_end - t_start);



    par.real_time = 0;//stores the time as calculated by the gillespie algorithm
    //================ Set RNG seeds ================================

    struct timeval time;
    gettimeofday(&time,NULL);

    if(randomSeed == false){

        cout << "====================================" << endl;
        cout << "Seed of random number generator is fixed" << endl;
        srand48(seed48);

//        if(verbose == true)
            cout << "Seed:  " << seed48 << endl;
    }
    else{
        cout << "====================================" << endl;
        cout << "Seed of random number generator is NOT fixed" << endl;
//        if(verbose == true)
        cout << "Seed:  " << ((time.tv_sec * 100) + (time.tv_usec / 100)) << endl;
        srand48((time.tv_sec * 100) + (time.tv_usec / 100));

    }


    //Activate or deactivate inhibition
    if(par.mode_inhib == 1 and par.verbose == true){

        cout << "Inhibition is activated" << endl;
    }
    else if(par.mode_inhib == -1 and par.verbose == true){
        cout << "Inhibition is NOT activated" << endl;
    }


    //===========================================================================
    //==================== Build polymers and reaction tables ===================
    //===========================================================================



    //Set number of cellulose polymers in microfibril
    if((par.mode_code==1) or (par.mode_code==2))
        nbr_poly_cellu=24;
    else if((par.mode_code==3) or (par.mode_code==4))
        nbr_poly_cellu=18;
    else if((par.mode_code==5) or (par.mode_code==6))//par.mode_code=6 IS CURRENTLY NOT IMPLEMENTED
        nbr_poly_cellu=36;
    else if(par.mode_code == 42)
        nbr_poly_cellu = 1;


    par.ends_blocked_per_CBH = 0.;
    
    par.number_of_cellu = nbr_poly_cellu ;

    if(par.verbose == true){
        cout << "mode_code = " << par.mode_code << endl;
        cout << "nbr poly cellu: " << nbr_poly_cellu << endl;
    }


    //====================== Build cellulose polymers ======================

    for(int i=0; i<nbr_poly_cellu; i++)
    {

        cellu.push_back(bList());
        cellu[i].index=i;
        cellu[i].set_z(0);

        Table_cellu.push_back(TList());
        initTList(Table_cellu[Table_cellu.size()-1],i);
        cellu[i].reactionTable = Table_cellu.size() - 1;
    }



    for(int i=0; i<nbr_poly_cellu; i++)
    {
        for(int j=0; j<par.length_fibril; j++)
        {
            addbond(cellu[i],j,1,1, false);

        }
    }


//==============================================================================================================================================
//========================= Read input files which are related to the positioning of cellulose, hemicellulose and lignin =======================
//==============================================================================================================================================
    // Normalising input compistion values : partho

    par.pct_hemi = par.pct_hemi_uns / (par.pct_cellu_uns + par.pct_hemi_uns + par.pct_lign_uns);
    par.pct_lign = par.pct_lign_uns / (par.pct_cellu_uns + par.pct_hemi_uns + par.pct_lign_uns);
    par.pct_glc = par.pct_cellu_uns / (par.pct_cellu_uns + par.pct_hemi_uns + par.pct_lign_uns);

    //par.pct_glc = 1. - par.pct_lign - par.pct_hemi;//Calculated cellulose percentage from hemicellulose and lignin percentages provided in parameter files
    if (par.verbose == true){
        cout << "----------------------------------------------------------------------------------" << endl;
        cout << "Unscaled composition (cellu:hemi:lign) - \t" << par.pct_cellu_uns << " : " << par.pct_hemi_uns << " : " << par.pct_lign_uns << endl;
        cout << "----------------------------------------------------------------------------------" << endl;
        cout << "Rescaled composition (cellu:hemi:lign) - \t" << par.pct_glc << " : " << par.pct_hemi << " : " << par.pct_lign << endl;
        cout << "----------------------------------------------------------------------------------" << endl;
    }



    //This file defines the configuration of the fibril withOUT regard to the availability of the bonds (conditioned by the positioning and amounts of lignin and hemicellulose)

    //Provide cellu with coordinates
    par.input_file = par.paramFileDir + par.structParams + to_string(par.mode_code) + ".txt";
    ifstream file1(par.input_file);
    line.clear();
    if(file1)
    {
        int i =0;
        while(getline(file1,line))
        {
            istringstream in(line);
            in >> cellu[i].x >> cellu[i].y;
            i++;
        }
    }
    else{
        cout << "File " << par.input_file << " does not exist. Exiting." << endl;
        exit(1);
    }




    vector<int> N_positions_in_layer;//defines the number of polymers per layer
    for(int i=1;i<= par.N_layers;i++){
        N_positions_in_layer.push_back(0);
    }


    x_pos_hemi.clear();
    y_pos_hemi.clear();
    x_pos_lign.clear();
    y_pos_lign.clear();
    vect_hemi_x.clear();
    vect_hemi_y.clear();
    vect_lign_x.clear();
    vect_lign_y.clear();





    for(int i = 0; i<par.N_layers;i++){
        vector<double> new_vec;
        x_pos_hemi.push_back(new_vec);
        y_pos_hemi.push_back(new_vec);
        x_pos_lign.push_back(new_vec);
        y_pos_lign.push_back(new_vec);

    	//Read in layer files
    	par.input_file = par.paramFileDir + par.hydroParams + "_" + to_string(par.mode_hemi) + "_" + to_string(par.mode_code) + "_layer_" + to_string(i+1) + ".txt";
        ifstream file4(par.input_file);
        line.clear();

        if(file4){
            int j =0;
            while(getline(file4,line))
            {
                x_pos_hemi[i].push_back(0);
                y_pos_hemi[i].push_back(0);
                istringstream in(line);
                in >> x_pos_hemi[i][j] >> y_pos_hemi[i][j];
                j++;
            }
        }
        else{
            cout << "File " << par.input_file << " does not exist. Exiting." << endl;
            exit(1);
        }




    	par.input_file = par.paramFileDir + par.hydroParams + "_" + to_string(par.mode_lign) + "_" + to_string(par.mode_code) + "_layer_" + to_string(i+1) + ".txt";

        ifstream file5(par.input_file);
        line.clear();
        if(file5)
        {
            int j =0;
            while(getline(file5,line))
            {
                x_pos_lign[i].push_back(0);
                y_pos_lign[i].push_back(0);
                istringstream in(line);
                in >> x_pos_lign[i][j] >> y_pos_lign[i][j];
                j++;
            }
        }
        else{
            cout << "File " << par.input_file << " does not exist. Exiting." << endl;
            exit(1);
        }


    }


    int N_possible_shell_polys = 0;
    int N_polys_required = nbr_poly_cellu/par.pct_glc - nbr_poly_cellu;//Number of polymers surrounding the cellulose core calculated from percentages


    if(par.mode_hemi == par.mode_lign){//This means that the content of x_pos_hemi is the same as that of x_pos_lign, and analogously for the y_pos vectors
        for(int i=0;i<x_pos_hemi.size();i++){
            N_possible_shell_polys += x_pos_hemi[i].size();
        }
        int polys_to_place = 0;//This determines, how many positions are to be filled by hemi and lign polymers
        if(N_possible_shell_polys < N_polys_required){
            if(par.verbose == true){
                cout << "Cellulose will be shortened to allow for the percentages specified for hemicellulose and lignin" << endl;
            }
            adjust_cellu = 1;
            polys_to_place = N_possible_shell_polys;
        }
        else{
            polys_to_place = N_polys_required;
        }

        int hemi_polys_to_place = int(par.pct_hemi * double(polys_to_place+nbr_poly_cellu));
        int lign_polys_to_place = int(par.pct_lign * double(polys_to_place+nbr_poly_cellu));
        if(hemi_polys_to_place+lign_polys_to_place > polys_to_place){
            if(par.verbose == true){
                cout << "hemi_polys_to_place+lign_polys_to_place > polys_to_place. Scaling down. Before: " << endl;
                cout << "hemi_polys_to_place = " << hemi_polys_to_place << "; lign_polys_to_place = " << lign_polys_to_place << "; placeable polys = " << polys_to_place << endl;
            }
            double scale_factor = double(polys_to_place)/double(hemi_polys_to_place+lign_polys_to_place);
            hemi_polys_to_place = int(hemi_polys_to_place * scale_factor);
            lign_polys_to_place = int(lign_polys_to_place * scale_factor);
            if(par.verbose == true){
                cout << "Afterwards: " << endl;
                cout << "hemi_polys_to_place = " << hemi_polys_to_place << "; lign_polys_to_place = " << lign_polys_to_place << "; placeable polys = " << polys_to_place << endl;
            }
//            exit(1);
            if(hemi_polys_to_place+lign_polys_to_place < polys_to_place){
                if(hemi_polys_to_place<lign_polys_to_place){
                    hemi_polys_to_place++;
                }
                else{
                    lign_polys_to_place++;
                }
            }
        }
        else{
            if(hemi_polys_to_place+lign_polys_to_place < polys_to_place){
                while(double(hemi_polys_to_place)/double(hemi_polys_to_place+lign_polys_to_place+nbr_poly_cellu) < par.pct_hemi and hemi_polys_to_place+lign_polys_to_place < N_possible_shell_polys){//Check if there are enough hemi polys
                    hemi_polys_to_place++;
                }
                while(double(lign_polys_to_place)/double(hemi_polys_to_place+lign_polys_to_place+nbr_poly_cellu) < par.pct_lign and hemi_polys_to_place+lign_polys_to_place < N_possible_shell_polys){
                    lign_polys_to_place++;
                }
            }
        }
        if(hemi_polys_to_place+lign_polys_to_place > N_possible_shell_polys){
           cout << "hemi_polys_to_place+lign_polys_to_place != polys_to_place. This should not be the case here. Stopping." << endl;
           exit(1);
        }
        double pct_hemi_per_layer = double(hemi_polys_to_place) / (double(hemi_polys_to_place) + double(lign_polys_to_place));
        double pct_lign_per_layer = 1. - pct_hemi_per_layer;

        for(int i=0; i<x_pos_hemi.size();i++){
            while(x_pos_hemi[i].size() != 0 and (vect_hemi_x.size() < hemi_polys_to_place or vect_lign_x.size() < lign_polys_to_place)){

                int position_index = int(drand48()*(x_pos_hemi[i].size()-1));
                double hemi_or_lign = drand48();
                bool placement_bool = false;
                if(hemi_or_lign <= pct_hemi_per_layer and vect_hemi_x.size() < hemi_polys_to_place){//place a hemicellulose polymer at these coordinates
                    vect_hemi_x.push_back(x_pos_hemi[i][position_index]);
                    vect_hemi_y.push_back(y_pos_hemi[i][position_index]);
                    placement_bool = true;
                }
                else{//place a lignin polymer at these coordinates
                    if(vect_lign_x.size() < lign_polys_to_place){
                        vect_lign_x.push_back(x_pos_lign[i][position_index]);
                        vect_lign_y.push_back(y_pos_lign[i][position_index]);
                        placement_bool = true;
                    }
                }
                if(placement_bool == true){
                    x_pos_hemi[i].erase(x_pos_hemi[i].begin()+position_index);
                    y_pos_hemi[i].erase(y_pos_hemi[i].begin()+position_index);
                    x_pos_lign[i].erase(x_pos_lign[i].begin()+position_index);
                    y_pos_lign[i].erase(y_pos_lign[i].begin()+position_index);
                }
            }

        }
    }
    else{//This means that x_pos_hemi contains different coordinates than x_pos_lign, and analogously for the y_pos vectors
        int N_possible_hemi_polys = 0;
        int N_possible_lign_polys = 0;
        for(int i=0;i<x_pos_hemi.size();i++){
            N_possible_hemi_polys += x_pos_hemi[i].size();
        }
        for(int i=0;i<x_pos_lign.size();i++){
            N_possible_lign_polys += x_pos_lign[i].size();
        }
        int hemi_polys_to_place = int(par.pct_hemi * double(N_polys_required+nbr_poly_cellu));
        int lign_polys_to_place = int(par.pct_lign * double(N_polys_required+nbr_poly_cellu));


        if(N_possible_hemi_polys < hemi_polys_to_place){
            if(par.verbose == true){
                cout << "Cellulose will be shortened to allow for the percentages specified for hemicellulose and lignin" << endl;
            }
            adjust_cellu = 1;
            hemi_polys_to_place = N_possible_hemi_polys;
        }
        if(N_possible_lign_polys < lign_polys_to_place){
            if(par.verbose == true){
                cout << "Cellulose will be shortened to allow for the percentages specified for hemicellulose and lignin" << endl;
            }
            adjust_cellu = 1;
            lign_polys_to_place = N_possible_lign_polys;
        }
        bool break_bool = false;
        for(int i=0; i<x_pos_hemi.size(); i++){
            for(int j=0; j<x_pos_hemi[i].size(); j++){
                if(vect_hemi_x.size() < hemi_polys_to_place){
                    vect_hemi_x.push_back(x_pos_hemi[i][j]);
                    vect_hemi_y.push_back(y_pos_hemi[i][j]);
                }
                else{
                    break_bool = true;
                    break;
                }
            }
            if(break_bool == true){
                break;
            }
        }
        break_bool = false;
        for(int i=0; i<x_pos_lign.size(); i++){
            for(int j=0; j<x_pos_lign[i].size(); j++){
                if(vect_lign_x.size() < lign_polys_to_place){
                    vect_lign_x.push_back(x_pos_lign[i][j]);
                    vect_lign_y.push_back(y_pos_lign[i][j]);
                }
                else{
                    break_bool = true;
                    break;
                }
            }
            if(break_bool == true){
                break;
            }
        }

    }



    if(par.verbose == true){
        cout << "Number of hemi polymers to be added: " << vect_hemi_x.size() << "; lignin: " << vect_lign_x.size() << endl;
        cout << "Number of hemi polymers to be added: " << vect_hemi_y.size() << "; lignin: " << vect_lign_y.size() << endl;
    }






    if(par.verbose == true){
        cout << "adjust_cellu = " << adjust_cellu << endl;
    }
     if(adjust_cellu == 1){
        int cutoff_cellu = 0;//This is set to a value other than 0 if the cellulose polymers need to be shortened. This is the case when the cellulose-percentage is lower than can be realized for same-length polymers with the specified microfibril shape
        int new_length = (-1*int(double(par.length_fibril+1)*(double(vect_hemi_x.size()+vect_lign_x.size())/(double(nbr_poly_cellu)-double(nbr_poly_cellu/par.pct_glc))))-1);
//        new_length-= (int(double(par.length_fibril+1)/double(nbr_poly_cellu))+1);
        if(par.verbose == true){
            cout << "New cellulose polymer length = " << new_length << endl;
            cout << "length_fibril+1 = " <<  par.length_fibril+1 << endl;
            cout << "nbr_poly_cellu = " <<  nbr_poly_cellu << endl;
            cout << "nbr_poly_hemi = " <<  vect_hemi_x.size() << endl;
            cout << "nbr_poly_lign = " <<  vect_lign_x.size() << endl;
            cout << "pct_glc = " <<  par.pct_glc << endl;
        }

        new_length = par.length_fibril+1 - new_length;//This is now the overall length to be cut off from the cellulose
        cutoff_cellu = int(0.5*double(new_length));
        for(int i=0;i<nbr_poly_cellu;i++){
            taylorNewPoly(cellu[i],cutoff_cellu);//Erase beginning of polymer
            taylorOldPoly(cellu[i],cellu[i].len_poly-1-cutoff_cellu);//Erase end of polymer
        }
    }


    //==========================================================================================================================
    //========================== Initiation of lignin and hemicellulose structures and acetylation =============================
    //==========================================================================================================================

    //Initiate elements for hemicellulose

    cout << "====================================" << endl;
    cout << "Building hemi and lignin polymers" << endl;





    nbr_poly_hemi = 0;
    for(int i=0; i<vect_hemi_x.size(); i++)
    {

        hemi.push_back(bList());
        nbr_poly_hemi++;
        hemi[i].x=vect_hemi_x[i];
        hemi[i].y=vect_hemi_y[i];
        hemi[i].set_z(0);

        Table_hemi.push_back(TList());
        initTList(Table_hemi[Table_hemi.size()-1],i);
        //cout << Table_hemi.size() << endl;
        hemi[i].reactionTable = Table_hemi.size() - 1;

        for(int j=0; j<par.length_fibril; j++){
    		if(par.init_XYL > 0)
	            addbond(hemi[i],j,1,4, false);
	        else
	        	addbond(hemi[i],j,-1,4, false);
        }
    }

    //Distribute bond types in hemicellulose: 1 for glc-glc, 2 for xyl-glc, 3 for glc-xyl, 4 for xyl-xyl, and -1 for lign-lign. For now this is only important for hemicellulose

//    if (par.xyl_or_mlg == true){

        int DP3 = 0;
        int DP4 = 0;
        int DP5 = 0;

	    if(par.pct_xyl == 1){
	    	for(int i=0;i<hemi.size();i++){


            //    int mlg_stat=0;                         //partho
                int beta14_counter = 0;                   //partho
                int sugar_DP = 0;                         //partho
                double s_random = 0;                         //partho


            //    srand(7);  // fixed seed to MLG distribution for all MC runs

	    		for(int j=0;j<hemi[i].bond_type.size();j++)
                {

                    if (par.xyl_or_mlg == true){
                        hemi[i].bond_type[j] = 4;
                    }
                    else if (par.xyl_or_mlg == false){

                        if (sugar_DP==0){
                        //    s_random = (rand() % 10 + 1);     //call random number for deciding length of beta 1,4 chain in MLG  : partho
                        s_random = drand48();  
                        }
                    

                        if (s_random <= 0.6){                        //decides degree of polymerisation of the beta 1,4 chains : partho
                            sugar_DP = 3;
                        }
                        else if (s_random > 0.6 && s_random <= 0.9){
                            sugar_DP = 4;
                        }
                        else if (s_random > 0.9){
                            sugar_DP = 5;
                        }

                        if (sugar_DP == 3)
                        {
                            hemi[i].bond_type[j]=1;             //bond_type 4 for xyl-xyl, bondtype 1 for mlg beta 1,4, bondtype 5 for mlg beta 1,3; partho
                            beta14_counter +=1;
                            if (beta14_counter==3 && j<((hemi[i].bond_type.size()) - 1)){
                                hemi[i].bond_type[j]=5;         //bond_type 4 for xyl-xyl, bondtype 1 for mlg beta 1,4, bondtype 5 for mlg beta 1,3; partho
                                beta14_counter=0;
                                sugar_DP=0;
                                DP3++;                        
                            }
                        }


                        else if (sugar_DP == 4)
                        {
                            hemi[i].bond_type[j]=1;             //bond_type 4 for xyl-xyl, bondtype 1 for mlg beta 1,4, bondtype 5 for mlg beta 1,3; partho
                            beta14_counter +=1;
                            if (beta14_counter==4 && j<((hemi[i].bond_type.size()) - 1)){
                                hemi[i].bond_type[j]=5;         //bond_type 4 for xyl-xyl, bondtype 1 for mlg beta 1,4, bondtype 5 for mlg beta 1,3; partho
                                beta14_counter=0;
                                sugar_DP=0;
                                DP4++;                        
                            }
                        }

                        else if (sugar_DP == 5)
                        {
                            hemi[i].bond_type[j]=1;             //bond_type 4 for xyl-xyl, bondtype 1 for mlg beta 1,4, bondtype 5 for mlg beta 1,3; partho
                            beta14_counter +=1;
                            if (beta14_counter==5 && j<((hemi[i].bond_type.size()) - 1)){
                                hemi[i].bond_type[j]=5;         //bond_type 4 for xyl-xyl, bondtype 1 for mlg beta 1,4, bondtype 5 for mlg beta 1,3; partho
                                beta14_counter=0;
                                sugar_DP=0;
                                DP5++;                        
                            }
                        }    
                    }                    
                }
		    }
    	}

        if (par.verbose == true and par.xyl_or_mlg == false){
            cout << "For MLGs beta (1-4) bonds:  DP3 = " << DP3 <<" ; DP4 = " << DP4 << " ; DP5 = " << DP5 << endl;
        }
//    }

	count_xyl = 0;
	count_glc = 0;

	for(int k=0;k<hemi.size();k++){

		if(hemi[k].bond_type[0] == 1 or hemi[k].bond_type[0] == 3 or hemi[k].bond_type[0] == 5)   // Partho new bond
			count_glc++;
		else if(hemi[k].bond_type[0] == 0){
			cout << "A bond_type in hemi is 0! This must have happened during initialization." << endl;
			exit(1);
		}
		else
			count_xyl++;

		for(int i=1;i<hemi[k].bond_type.size();i++){

		if(hemi[k].bond_type[i-1] == 1 or hemi[k].bond_type[i-1] == 2 or hemi[k].bond_type[i-1] == 5)     //Partho new bond
			count_glc++;
		else if(hemi[k].bond_type[i] == 0){
			cout << "A bond_type in hemi is 0! This must have happened during initialization." << endl;
			exit(1);
		}
		else
			count_xyl++;
		}
	}
    if(par.verbose == true){
    	cout << "Xylose percentage in hemicellulose: " << double(count_xyl)/double(par.length_fibril * hemi.size()) << "; Glucose percentage in hemicellulose: " <<  double(count_glc)/double(par.length_fibril*hemi.size()) << endl;
    }






//    nbr_poly_hemi=vect_hemi_x.size();
    nbr_bd_hemi=nbr_poly_hemi*par.length_fibril;

    //Acetylation of hemicellulose (ACETYLATION CURRENTLY HAS NO EFFECT)
    counter=0;
    if(par.pct_acetyl_hemi > 0){
	    while(counter<nbr_bd_hemi*par.pct_acetyl_hemi)
	    {

	        x1 = int(drand48()*(nbr_poly_hemi));//x1 ranges from 0 to Tot_hemi-1
	        x2 = int(drand48()*(par.length_fibril));

	        if(hemi[x1].status[x2]==1)//If this position is not acetylated
	        {
	            hemi[x1].status[x2]=-2;
	            counter++;
	        }
	    }
    }

    //Initiate elements for lignin
    nbr_poly_lign = 0;
    for(int i=0; i<vect_lign_x.size(); i++)
    {
        lign.push_back(bList());
        nbr_poly_lign++;
        lign[i].x=vect_lign_x[i];
        lign[i].y=vect_lign_y[i];
        lign[i].set_z(0);

        for(int j=0; j<par.length_fibril; j++)
            addbond(lign[i],j,-2,-1, false);
    }

    //Distribute covering parameters for polymers
    distribute_lignin_covering(par,lign);


//    nbr_poly_lign=vect_lign_x.size();
    nbr_poly_overall = nbr_poly_cellu + nbr_poly_hemi + nbr_poly_lign;


    if(par.verbose == true){
        cout << "Number of hemi polys: " << nbr_poly_hemi << "; number of lignin polys: " << nbr_poly_lign << endl;
    }
    min_max_cellu_hemi_lign(cellu,par);//Set coordinates of boundaries for hemi and lign



    //======================================================================================
    //========================= Adjust hemicellulose and lignin ============================
    //======================================================================================



    if(cellu.size() < 1){
        cout << "No cellulose in microfibril! stopping" << endl;
        exit(1);
    }
    if(par.verbose == true){
        cout << "\n Length of cellu[0] in monomers: " << cellu[0].len_poly + 1 << endl;
    }
    Nbr_glc_in_cellu = (cellu[0].len_poly+1) * nbr_poly_cellu;//We need to use the actual length of the cellulose here instead of par.length_fibril, because in some cases (e.g. low cellulose percentage) the cellulose polymers are shortened beforehand

    nbr_molecs_overall = int(double(Nbr_glc_in_cellu)/(par.pct_glc));//Overall number of monomers

    Nbr_xyl_in_hemi = int(nbr_molecs_overall * par.pct_hemi);
    Nbr_lignol_in_lign = int(nbr_molecs_overall * par.pct_lign);



    int difference_hemi = nbr_poly_hemi * (par.length_fibril + 1) - Nbr_xyl_in_hemi;
    int difference_lign  = nbr_poly_lign * (par.length_fibril + 1) - Nbr_lignol_in_lign;
    if(verbose == true){
        cout << "difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign << "\n" << endl;
    }

    cout << "====================================" << endl;
    cout << "Adjusting hemi and lign..." << endl;



    if(nbr_poly_hemi > 0){

        if(difference_hemi < 0){
            difference_lign -= difference_hemi;
            difference_hemi = 0;
            if(verbose == true){
                cout << "Difference_hemi was < 0 and was adjusted; difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign << "; nbr_poly_hemi = " << nbr_poly_hemi << "; nbr_poly_lign = " << nbr_poly_lign << endl;
            }
  //          exit(1);
        }
        if(difference_lign < 0){
            difference_hemi -= difference_lign;
            difference_lign = 0;
            if(verbose == true){
                cout << "Difference_lign was < 0 and was adjusted; difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign  << "; nbr_poly_hemi = " << nbr_poly_hemi << "; nbr_poly_lign = " << nbr_poly_lign << endl;
            }
//            exit(1);
        }
        if(difference_hemi > 0 or difference_lign > 0){
            if(difference_hemi > 0){
                hole_cutter(hemi,Table_hemi,par,difference_hemi,nbr_poly_hemi,2);
            }
            if(difference_lign > 0){
                hole_cutter(lign,Table_hemi,par,difference_lign,nbr_poly_lign,3);
            }
//            hole_cutter(cellu, hemi, lign, Table_hemi, par, difference_hemi, difference_lign, nbr_poly_hemi, nbr_poly_lign, error_bool, 2);

        }
        else if(difference_hemi == 0 and par.verbose == true){
            cout << "difference_hemi = 0" << endl;
        }
    }
    cout << "====================================" << endl;
    cout << "Done adjusting hemi and lign" << endl;


    Nbr_xyl_in_hemi = 0;
    Nbr_lignol_in_lign = 0;
    for(int i=0; i<nbr_poly_hemi;i++){
        Nbr_xyl_in_hemi += (hemi[i].len_poly + 1);
    }
    for(int i=0; i<nbr_poly_lign; i++){
        Nbr_lignol_in_lign += (lign[i].len_poly + 1);
    }
    par.nbr_monolignol = Nbr_lignol_in_lign;




    if(par.toy_model == true){
        cout << "====================================" << endl;
        cout << "toy model is active; adjusting x- and y coordinates of polymers such they are not close to each other anymore" << endl;
        for(int i=0; i<nbr_poly_cellu;i++){
            cellu[i].x *= 100;
            cellu[i].y *= 100;
        }
        for(int i=0; i<nbr_poly_hemi;i++){
            hemi[i].x *= 100;
            hemi[i].y *= 100;
        }
        for(int i=0; i<nbr_poly_lign; i++){
            lign[i].x *= 100;
            lign[i].y *= 100;
        }

    }


// ===========================================================================================================
// =============================== Build maps of neighboring bonds =========================================
// ===========================================================================================================


//    char neighbor_key[3];//Stores the three coordinates used to find the neighbor entry within the neighbor maps
    cout << "====================================" << endl;
    cout << "Filling neighbor vectors" << endl;
    if(verbose==true){

        cout << "enzyme radius = " << par.enzyme_radius << "; monomer radius = " << par.r_monomer << endl;


        cout << "Sizes before: cellu_neighbors: " << bond_neighbors_cellu.size() << "; hemi: " << bond_neighbors_hemi.size() << endl;
    }
    for(int i=0;i<nbr_poly_cellu;i++){

        for(int j=0;j<cellu[i].len_poly;j++){
            neighbor_key = std::make_tuple(cellu[i].x,cellu[i].y, cellu[i].z[j]);

            if(bond_neighbors_cellu.count(neighbor_key) == 0){
                bond_neighbors_cellu.insert({neighbor_key, neighborList(cellu[i].x, cellu[i].y, cellu[i].z[j], neighbor_check_radius, par.mid_x, par.mid_y, par.r_monomer, cellu, hemi, lign)});
                if(par.toy_model == true){
                    bond_neighbors_cellu[neighbor_key].outer_bond = true;
                }
            }

        }
    }
    for(int i=0;i<nbr_poly_hemi;i++){

        for(int j=0;j<hemi[i].len_poly;j++){
            neighbor_key = std::make_tuple(hemi[i].x,hemi[i].y, hemi[i].z[j]);

            if(bond_neighbors_hemi.count(neighbor_key) == 0){
                bond_neighbors_hemi.insert({neighbor_key, neighborList(hemi[i].x, hemi[i].y, hemi[i].z[j], neighbor_check_radius, par.mid_x, par.mid_y, par.r_monomer, cellu, hemi, lign)});
                if(par.toy_model == true){
                    bond_neighbors_hemi[neighbor_key].outer_bond = true;
                }
            }
        }
    }
    cout << "====================================" << endl;
    cout << "Done filling neighbor vectors" << endl;


    if(verbose == true){
        cout << "************************************" << endl;
        cout << "Size of cellu neighbors: " << bond_neighbors_cellu.size() << endl;
        cout << "Size of hemi neighbors: " << bond_neighbors_hemi.size() << endl;
        cout << "************************************" << endl;

        if(nbr_poly_cellu > 0){
            neighbor_key = std::make_tuple(cellu[0].x,cellu[0].y, cellu[0].z[0]);
            cout << "Neighbors of first cellu bond: " << bond_neighbors_cellu[neighbor_key].N_neighbors << endl;
        }

    }



    //====================== Set statuses of cellu and hemi bonds ==================================================


    // ====================  Accessibility of Xyl bonds based on anchoring of lignin and hemicellulose =============================


    if(nbr_poly_hemi > 0){

        for(int i = 0;i<nbr_poly_hemi;i++){

        	if(hemi[i].len_poly>0){
                hemi[i].status[0] = 1;
                hemi[i].status[hemi[i].len_poly-1] = 1;
                for(int j=1;j<hemi[i].len_poly-1;j++){
                    if(bond_neighbors_hemi[std::make_tuple(hemi[i].x, hemi[i].y, hemi[i].z[j])].outer_bond == true){
	                    hemi[i].status[j] = 1;
                    }
		            else{
		                hemi[i].status[j] = -1;
		            }

	            }


        	}
        }
    }




    // ========================  Initial configuration of chemical entities ===================================


    //Fill chemical entities vector. Contains enzyme concentrations and amount of monolignols
    for(int i=0; i<5; i++)
        chem_entities.push_back(0.0);

    chem_entities[0] = par.init_EG;
    chem_entities[1] = par.init_CBH;
    chem_entities[2] = par.init_BGL;
    chem_entities[3] = par.init_XYL;
    chem_entities[4] = par.nbr_monolignol;


    //Fill propensities and crystal_propensities vectors. These contain the values for the propensities of reactions of each possible type. The reactions themselves will contain pointers to these vectors
    for(int i=1;i<7;i++){
    	par.propensities.push_back(prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,i,chem_entities,nbr_Glc_pdt,nbr_cellobiose));
    	if(i!=4){
	    	par.crystal_propensities.push_back(par.crystal_modifier_cellu*prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,i,chem_entities,nbr_Glc_pdt,nbr_cellobiose));
    	}
    	else{
    		par.crystal_propensities.push_back(par.crystal_modifier_hemi * prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,i,chem_entities,nbr_Glc_pdt,nbr_cellobiose));
    	}
    }

    if(par.verbose == true){
        cout << "number of enzymes which can at most be blocked by lignin: " << int(par.nbr_monolignol / par.lignols_blocked_per_enzyme) << endl;
    }

    par.nbr_lignin_blocked = 0;//No enzymes are bound to lignin yet


    par.N_free_ends = 0;//The number of free ends has not been measured yet and is initialized to 0





    // ========================  Set crystallinity =================================== //


    int count_crystalline = 0;
    int count_cellu = countGlc(cellu,1);
    int z_crystal_lower = 0;
    int z_crystal_upper = 0;
    int defect_size;
    double defect_sum_extra = 0;    
    int defect_ctr = 0;
    int defect_sub_ctr = 0;
    double dist_ij = 0.0;


    int nearest_neighbor_cellu = 0;

    double nhbr_dist;

    
    std::vector<int> defects;                   // partho: vector for saving the sizes of defects 

    std::vector<int> outer_cellulose;           // partho: vector for indexes of outer cellu polymers
 
    std::vector<int> outer_cellu_neighbors;     // partho: vector for cellu neighbors of outer cellu poly 
    
    // Finding Outer cellulose polymers : partho
    if (par.pct_crystalline_cellu > 0.0 and par.pct_crystalline_cellu < 1){
        
        defect_ctr = 0;
        defect_sub_ctr = 0;
        dist_ij = 0.0;


        nearest_neighbor_cellu = 0;
        
        // Conditions of nearest neighbor distance for different Mode_codes : partho
        nhbr_dist = 0.84;    // For Mode_code: 1,2,3,4,5


        for (int i=0;i<nbr_poly_cellu;i++){
            nearest_neighbor_cellu = 0;
            for (int j=0;j<nbr_poly_cellu;j++){
                if (i != j){
                    
                    dist_ij= pow((abs(cellu[i].x - cellu[j].x)),1) + pow((abs(cellu[i].y - cellu[j].y)),1);
                    
                    if (dist_ij <= nhbr_dist){
                        nearest_neighbor_cellu++;
                    }                    
                }
            }

            if (nearest_neighbor_cellu <= 5){
                outer_cellulose.push_back(i); // partho: stores index of Outer cellu polymers
            }
        }
    }

    int N_amor_core2 = int (par.N_amor_core * outer_cellulose.size());  // finding number of defects that is a fraction (file input) of the total number of outer cellu polys : partho   
    int dfct_size2 = int (par.dfct_size * par.length_fibril * (1 - par.pct_crystalline_cellu));     // finding mean size of a defect depending on input parameter which describes the fraction of amorphous cellulose in these defects : partho


    /// Printing outer bond index_poly : partho
    /*
    if (par.verbose == true){
        cout << "***** Outer cellu polymer chain index *****" << endl;
        for (auto it = outer_cellulose.begin(); it != outer_cellulose.end(); ++it){
            cout << "** Outer polymer =  " << *it << endl;
        }
        cout << "------------------------------------------------" << endl;
        cout << "------------------------------------------------" << endl;
    }*/



    for (int i=0;i<N_amor_core2;i++){
        defect_size = dfct_size2 * box_muller(0.25,1.);
        defects.push_back(defect_size);
    }

    if (par.verbose == true){
        cout << "Mean defect size input from file =  " << dfct_size2 << endl;
        cout << "Number of Defects = " << N_amor_core2 << endl;
    }

    for (auto it = defects.begin(); it != defects.end(); ++it){

        defect_size = *it;
        defect_sum_extra +=*it;

        if (par.verbose == true){
            cout << "DEFECT SIZE =  "<< defect_size << endl;
        }
    }



    defect_sum_extra = defect_sum_extra/nbr_poly_cellu;

    if (par.verbose == true){
       cout << "defect extra =  " << defect_sum_extra << endl;
    }






    if(par.pct_crystalline_cellu > 0 and par.pct_crystalline_cellu <= 1){



        z_crystal_lower = int((par.length_fibril-1) * 0.5 * (1. - par.pct_crystalline_cellu)) - round(defect_sum_extra/2);   //partho changed crystal limits
        z_crystal_upper = par.length_fibril - 1 - z_crystal_lower;// partho changed crystal limits

        if(par.verbose == true){
            cout << "Cellulose is crystalline between z lower = " << z_crystal_lower << " & z upper = " << z_crystal_upper << endl;
        }

        for(int i=0;i<nbr_poly_cellu;i++){
            for(int j=0;j<cellu[i].len_poly;j++){
                // Partho changing crystal conditions
                if(cellu[i].z[j] >= z_crystal_lower and cellu[i].z[j] < z_crystal_upper){
                    cellu[i].crystalline[j] = true;
                    count_crystalline++;
                }
            }
        }



        // placing amorphous parts in the crystalline core : partho

       
       
        std::random_shuffle(outer_cellulose.begin(), outer_cellulose.end());
        std::random_shuffle(defects.begin(), defects.end());



        int random_index;

        int random_outer;


        for (auto it = defects.begin(); it != defects.end(); ++it)
        { // Loop for cutting defects

            defect_ctr = 0;

            defect_sub_ctr = 0;

            defect_size = *it;

            if (par.verbose == true){
                cout << "Defect size : " << defect_size << endl;
            }

           // random_index = rand()%outer_cellulose.size();

            random_index = int(drand48() * (outer_cellulose.size()));

            random_outer = outer_cellulose[random_index];  // Random Outer Cellu Poly number of defect start from outer Polys

            int zcu = z_crystal_upper - int((defect_size+2)/2);
            int zcl = z_crystal_lower + int((defect_size+2)/2);

            int v_rand = rand()%((zcu - zcl) + 1) + zcl;
        //    int v_rand2;

            int defect_org_bond = v_rand;

            int defect_bond_num = defect_org_bond;  // Random bond of defect start on Outer poly

            int defect_poly_num = random_outer;  // seclect random outer cellulose polymer

            int nghbr_1;

            int nghbr_2;

            int defect_bond_num1;

            int defect_bond_num2;
                        

            outer_cellu_neighbors.clear();

            for (int k1=0; k1<nbr_poly_cellu; ++k1){  // Finding nearest neighbors of selected poly
                if (k1 != random_outer){
                
                    dist_ij= pow((abs(cellu[random_outer].x - cellu[k1].x)),1) + pow((abs(cellu[random_outer].y - cellu[k1].y)),1);
                    
                    if (dist_ij <= nhbr_dist){
                        outer_cellu_neighbors.push_back(k1);
                    }                  
                }
            }

            std::random_shuffle(outer_cellu_neighbors.begin(), outer_cellu_neighbors.end());

            nghbr_1 = outer_cellu_neighbors[0];
            nghbr_2 = outer_cellu_neighbors[1];

            defect_bond_num1 = defect_org_bond + int(defect_size/8);
            defect_bond_num2 = defect_org_bond + int(defect_size/8);

            while (defect_ctr <  defect_size){

                if (defect_sub_ctr < (0.5*defect_size)){
                    if ( cellu[defect_poly_num].crystalline[defect_bond_num] = true){
                        cellu[defect_poly_num].crystalline[defect_bond_num] = false;
                        count_crystalline--;
                        defect_ctr++;
                        defect_sub_ctr++;
                        defect_bond_num++;
                    }
                    /*
                    if (par.verbose ==  true){
                        cout << "defect poly num = " << defect_poly_num << "    defect bond = " << defect_bond_num << "--size Now--"<< defect_ctr << endl;
                        cout << "--------------"<< endl;
                    }*/
                } 
                else if (cellu[defect_poly_num].crystalline[defect_bond_num] = false){
                    defect_bond_num--;
                }
                    
                   



                if (defect_sub_ctr >= (0.5*defect_size)){

                    // defect_bond_num = defect_org_bond;
                    //    defect_bond_num = defect_org_bond + int(defect_size/8);

                    if (cellu[nghbr_1].crystalline[defect_bond_num1] = true){
                        cellu[nghbr_1].crystalline[defect_bond_num1] = false;
                        count_crystalline--;
                        defect_ctr++;
                        defect_bond_num1++;
                        /*
                        if (par.verbose == true){
                            cout << "Defect cellu poly neighbor#1 = " << nghbr_1 <<"--bond = "<< defect_bond_num1 << "--size Now--"<< defect_ctr << endl;
                        } */
                    }
                    else if (cellu[nghbr_1].crystalline[defect_bond_num1] = false){
                        defect_bond_num1--;
                    }

                        

                    if (defect_ctr >= defect_size){
                        goto comehere;   // Loop break if defect size reached already
                    }

                    if (cellu[nghbr_2].crystalline[defect_bond_num2] = true){
                        cellu[nghbr_2].crystalline[defect_bond_num2] = false;
                        count_crystalline--;
                        defect_ctr++;
                        defect_bond_num2++;
                        /*
                        if (par.verbose == true){
                            cout << "Defect cellu poly neighbor#2 = " << nghbr_2 << "--bond = " << defect_bond_num2 << "--size Now--"<< defect_ctr << endl;
                        }*/
                    }
                    else if (cellu[nghbr_2].crystalline[defect_bond_num2] = false){
                        defect_bond_num2--;
                    }

                }


                comehere:

                if (par.verbose == true){
                }    

            }
        }

        

// Check for correct crystallinity value
        count_crystalline=0;

        for (int i=0;i<nbr_poly_cellu;i++){
            for (int j=0;j<cellu[i].len_poly;j++){
                if (cellu[i].crystalline[j] == true){
                    count_crystalline++;
                }
            }
        }





        if(par.verbose == true){
            cout << "User input cellulose crystallinity percentage =  " << par.pct_crystalline_cellu << endl;
            cout << "From code implementation, cellulose crystallinity percentage =  " << double(count_crystalline)/double(count_cellu) << endl;
        }
    }
    count_crystalline = 0;
    int count_hemi;

    if (par.xyl_or_mlg == true){
        count_hemi = countXyl(hemi);    //  partho comment count xyl in hemi        
    }
    else if (par.xyl_or_mlg == false){
        count_hemi = countGlc(hemi,2); // Partho counts glucose in hemi
    }

    int poly_to_crystalize = 0;
    int bond_to_crystalize = 0;
	if(par.pct_crystalline_hemi > 0 and par.pct_crystalline_hemi <= 1){
        if(par.pct_crystalline_cellu > 0 and par.pct_crystalline_cellu <= 1){
    	    for(int i=0;i<nbr_poly_hemi;i++){
    	    	for(int j=0;j<hemi[i].len_poly;j++){
                    if(bond_neighbors_hemi[make_tuple(hemi[i].x,hemi[i].y,hemi[i].z[j])].has_neighbor_material(1) == true and hemi[i].z[j] >= z_crystal_lower and hemi[i].z[j] < z_crystal_upper and cellu[i].crystalline[j]== true){ //partho comment
    	    			hemi[i].crystalline[j] = true;
    	    			count_crystalline++;
    	    		}
                    if(double(count_crystalline)/double(count_hemi) >= par.pct_crystalline_hemi){
                        break;
                    }
                    if(double(count_crystalline)/double(count_hemi) >= par.pct_crystalline_cellu){
                        break;
                    } 
    //    			count_hemi++;
    	    	}
                if(double(count_crystalline)/double(count_hemi) >= par.pct_crystalline_hemi){
                    break;
                }
                if(double(count_crystalline)/double(count_hemi) >= par.pct_crystalline_cellu){
                    break;
                }
    	    }
        }
        else{
            if(par.verbose == true){
                cout << "no crystalline cellu! Therefore, no crystalline hemicellulose will be generated, as the condition for hemicellulose being crystalline is that it is adjacent to crystalline cellulose" << endl;
            }
        }

        if(par.verbose == true){
            cout << "User input hemi crystalline percentage = " << par.pct_crystalline_hemi << endl;
    	    cout << "From code implementation, hemi crystalline percentage = " << double(count_crystalline)/double(count_hemi) << endl;
        }
        double diff_epsilon = 0.01;
        if (abs(double(count_crystalline)/double(count_hemi)-par.pct_crystalline_hemi)/par.pct_crystalline_hemi > diff_epsilon and par.verbose == true){
            cout << "The condition for hemicellulose being crystalline is that it is adjacent to crystalline cellulose. The number of hemi bonds that fit this condition is insufficient to reach the given crystallinity percentage." << endl;
        }
	}


    //=========================== Accessibility of Glc bonds based on their position in the bulk of the fibril and anchoring of hemi and lign =========================

   for(int i=0;i<nbr_poly_cellu;i++){
        if(par.length_fibril>1){


            //Add ends to free end vector
/*
            cellu[i].status[0] = 1;//The tip of the polymer is still attackable by CBH
            cellu[i].status[1] = 1;//But CBH attacks the second bond from the top/bottom
            cellu[i].status[cellu[i].len_poly-1] = 1;
            cellu[i].status[cellu[i].len_poly-2] = 1;*/

             for(int j=0; j<cellu[i].len_poly; j++){
                if(bond_neighbors_cellu[std::make_tuple(cellu[i].x, cellu[i].y, cellu[i].z[j])].outer_bond == true){
                    cellu[i].status[j] = 1;
                    if(j == 1){
                        par.free_poly_ends.insert({cantor_pair_two(i,1), make_tuple(i,1)});
                        addreaction(Table_cellu,par,0,Table_cellu,i,1,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[i].crystalline[1]);//This already adds the corresponding reaction

                        par.N_free_ends++;
                    }
                    else if(j == cellu[i].len_poly-2){
                        par.free_poly_ends.insert({cantor_pair_two(i,cellu[i].len_poly-2), make_tuple(i,cellu[i].len_poly-2)});
                        addreaction(Table_cellu,par,0,Table_cellu,i,cellu[i].len_poly-2,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[i].crystalline[cellu[i].len_poly-2]);//This already adds the corresponding reaction
                        par.N_free_ends++;
                    }
                }
            	else{
                    cellu[i].status[j]=-1;
            	}
            }
        }
        else if(par.length_fibril == 1){
            cellu[i].status[0] = 1;
        }
        else{
            cout << "fibril length is 0. Stopping." << endl;
            exit(1);
        }
    }






    par.propensities[5] = prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose);
    par.crystal_propensities[5] = par.crystal_modifier_cellu * prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose);

    for(int i=0;i<Table_cellu.size();i++){
        Table_cellu[i].calcTableProp();
    }

    // ================================================================================================
    // ======================  Finalize filling of propensity tables ==================================
    // ================================================================================================



    //Fill cellu tables
    for(int i=0;i<Table_cellu.size();i++){
        fill_table(Table_cellu,cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,Table_cellu, cellu, i, 1, error_bool,chem_entities,nbr_Glc_pdt,nbr_cellobiose);
        if(par.verbose == true){
            for(int j=0;j<Table_cellu[i].nbr_element;j++){
                if(Table_cellu[i].num_bond[j] == 0 or Table_cellu[i].num_bond[j] == 1 or Table_cellu[i].num_bond[j] == cellu[i].len_poly-1 or Table_cellu[i].num_bond[j] == cellu[i].len_poly-2){
                    if(Table_cellu[i].indic_action[j] == 1){
                        cout << "Function fill_table adds EG reactions at start or end! stopping" << endl;
                        exit(1);
                    }
                }
            }
        }
    }

    //Fill hemi tables
    for(int i=0;i<Table_hemi.size();i++){
        fill_table(Table_cellu,cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,Table_hemi, hemi, i, 2,error_bool,chem_entities,nbr_Glc_pdt,nbr_cellobiose);
        if(par.verbose == true){
            for(int j=0;j<Table_hemi[i].nbr_element;j++){
                if(Table_hemi[i].num_bond[j] >= hemi[i].len_poly){
                    cout << "Function fill_table() produces reactions in Table_hemi which point to bonds outside of the polymer length. Stopping" << endl;
                    exit(1);
                }
            }
        }
    }


    //======= Calculate propensity sum =======

    a0=0.;

    for(int i=0; i<nbr_poly_cellu; i++){//sum up propensities for cellu
        Table_cellu[i].calcTableProp();
        a0 += Table_cellu[i].prop_sum;

    }

    for(int i=0; i<nbr_poly_hemi; i++){//sum up propensities for hemi
        Table_hemi[i].calcTableProp();
        if(verbose == true){
        	cout << "Table_hemi[" << i << "].nbr_element = " << Table_hemi[i].nbr_element << "; prop_sum = " << Table_hemi[i].prop_sum << endl;
            cout << "Length of corresponding polymer: " << hemi[i].len_poly << endl;
        }
        a0 += Table_hemi[i].prop_sum;
    }



    	//=================== Check if tables were filled correctly =======================

    if(par.verbose == true){
        for(int i=0;i<Table_cellu.size();i++){
            for(int j=0;j<Table_cellu[i].nbr_element;j++){
                if(Table_cellu[i].indic_action[j] == 2 and (Table_cellu[i].num_bond[j] == 0 or Table_cellu[i].num_bond[j] == par.length_fibril - 1)){
                    cout << "Initialization of CBH reactions not correct: a reaction was found at bond " << Table_cellu[i].num_bond[j] << "; stopping..." << endl;
                    exit(1);
                }
                if(Table_cellu[i].indic_action[j] == 1 and (Table_cellu[i].num_bond[j] == 0 or Table_cellu[i].num_bond[j] == par.length_fibril - 1)){
                    cout << "Initialization of EG reactions not correct: a reaction was found at bond " << Table_cellu[i].num_bond[j] << "; stopping..." << endl;
                    exit(1);
                }
            }
        }
    }




    // =====================================================================================================
    // Print data on the initial state of the system to file (if this is activated via command line argument)
    // =====================================================================================================


    if(par.print_polys == true or par.verbose == true){
	    int count_available = 0;
	    int count_not_available = 0;
	    ofstream crystalFile("Output/3D/crystalline_cellu_bonds_" + to_string(current_run) + ".txt");
	    for(int i=0;i<nbr_poly_cellu;i++){
	        for(int j=0;j<cellu[i].len_poly;j++){
	            if(cellu[i].crystalline[j] == true){
	                crystalFile << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << endl;
	            }
	        }
	    }
	    crystalFile.close();

	    ofstream crystal_hemi_file("Output/3D/crystalline_hemi_bonds_" + to_string(current_run) + ".txt");
	    for(int i=0;i<nbr_poly_hemi;i++){
	        for(int j=0; j<hemi[i].len_poly; j++){
	            if(hemi[i].crystalline[j] == true){
	                crystal_hemi_file << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
	            }
	        }
	    }
	    crystal_hemi_file.close();


	    ofstream availableFile("Output/3D/available_cellu_bonds_" + to_string(current_run) + ".txt");
	    for(int i=0;i<nbr_poly_cellu;i++){
	        for(int j=0;j<cellu[i].len_poly;j++){
	            if(cellu[i].status[j] == 1){
	                count_available++;
	                availableFile << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << endl;
	            }
	            else if(cellu[i].status[j] == -1)
	                count_not_available++;
	            else
	                cout << "During initial configutation: bond status is neither -1 nor 1" << endl;
	        }
	    }
	    availableFile.close();
        if(par.verbose == true){
    	    cout << "available cellu bonds: " << count_available << endl;
    	    cout << "blocked cellu bonds: " << count_not_available << endl;
        }
	    ofstream availableHemiFile("Output/3D/available_hemi_bonds_" + to_string(current_run) + ".txt");
	    count_available = 0;
	    count_not_available = 0;
	    for(int i=0;i<nbr_poly_hemi;i++){
	        for(int j=0;j<hemi[i].len_poly;j++){
	            if(hemi[i].status[j] == 1){
	                count_available++;
	                availableHemiFile << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
	            }
	            else if(hemi[i].status[j] == -1){
	                count_not_available++;
	            }
	            else
	                cout << "During initial configutation: bond status is neither -1 nor 1" << endl;
	        }
	    }
	    availableHemiFile.close();
	    ofstream HemiFile("Output/3D/available_hemi_" + to_string(current_run) + ".txt");
	    for(int i=0;i<nbr_poly_hemi;i++){
	        for(int j=0;j<hemi[i].len_poly;j++){
	                HemiFile << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
	        }
	    }
		HemiFile.close();
	    ofstream ligninfile("Output/3D/available_lignin_bonds_" + to_string(current_run) + ".txt");
	    for(int i=0;i<nbr_poly_lign;i++){
	    	for(int j=0;j<lign[i].len_poly;j++){
	            if(lign[i].covering[j] == true)
	        		ligninfile << lign[i].x << "\t" << lign[i].y << "\t" << lign[i].z[j] << endl;
	    	}
	    }
	    ligninfile.close();
        if(par.verbose == true){
    	    cout << "available hemi bonds: " << count_available << endl;
    	    cout << "blocked hemi bonds: " << count_not_available << endl;
        }
    }




    //======================================================================================
    //========================= Add glueing reaction by lignin =============================
    //======================================================================================

    if(par.mode_lignin_glue == 1){
        initTList(Table_lign, 0);
        Table_lign.num_bond.push_back(0);
        Table_lign.material.push_back(0);
        Table_lign.indic_action.push_back(5);
        Table_lign.liste_prop.push_back(&par.propensities[4]);
        Table_lign.prop_uninhib.push_back(&par.propensities[4]);
        Table_lign.crystalline.push_back(0);
        Table_lign.covered.push_back(false);
        Table_lign.addProp(prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,5,chem_entities,nbr_Glc_pdt,nbr_cellobiose));
        Table_lign.nbr_element++;
        Table_lign.calcTableProp();
        if(par.verbose == true){
            cout << "Glue reaction prop: " << Table_lign.prop_sum << endl;
        }
    }
    else{
        initTList(Table_lign, 0);
        Table_lign.num_bond.push_back(0);
        Table_lign.material.push_back(0);
        Table_lign.indic_action.push_back(5);
        Table_lign.liste_prop.push_back(&par.propensities[4]);
        Table_lign.prop_uninhib.push_back(&par.propensities[4]);
        Table_lign.covered.push_back(false);
        Table_lign.crystalline.push_back(0);
        Table_lign.addProp(prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,5,chem_entities,nbr_Glc_pdt,nbr_cellobiose));
        Table_lign.nbr_element++;
        Table_lign.prop_sum = 0;
    }


    //Make sure that variables are set to 0 before starting the algorithm
    bond_selected = 0;
    poly_selected = 0;
    nbr_Glc_pdt = 0;
    nbr_xyl_pdt = 0;
    nbr_cellobiose = 0;



    //Calculate overall number of glucose and xylose in the system
    glucoseOverall = countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt;
    xyloseOverall = countXyl(hemi) + nbr_xyl_pdt;
    glcCelluBefore = countGlc(cellu,1);
    glcHemiBefore = countGlc(hemi,2);
    lignolBefore = countLign(lign);
    glcBefore = glcCelluBefore + glcHemiBefore + nbr_Glc_pdt;

    if(par.verbose == true){
        cout << "glucose in whole microfibril: " << glucoseOverall << endl;
        cout << "Number of hemicellulose polymers: " << nbr_poly_hemi << endl;
        cout << "Number of lignin polymers: " << nbr_poly_lign << endl;
        cout << "glucose in hemicellulose: " << countGlc(hemi,2) << endl;
        cout << "xylose in microfibril: " << xyloseOverall << endl;
        cout << "Bonds in cellulose: " << par.length_fibril * nbr_poly_cellu << endl;
    }


    if(par.verbose == true){
        cout << "a0 in the beginning is equal to " << a0 << endl;
    }

    for(int i=0;i<Table_cellu.size();i++){
        reactionsOverall+=Table_cellu[i].nbr_element;
    }
    for(int i=0;i<Table_hemi.size();i++){
        reactionsOverall+=Table_hemi[i].nbr_element;
    }

    if(par.length_fibril == 1){ // Check whether the fibril is made only of cellobiose
        nbr_cellobiose = nbr_poly_cellu;
        for(int i=0;i<hemi.size();i++){
        	if(hemi[i].bond_type[0] == 1)
	        	nbr_cellobiose += nbr_poly_hemi;
        }
    }
    else
        nbr_cellobiose = 0;



    // Some more error checking
    if(par.verbose == true){
        for(int i=0; i<Table_hemi.size();i++){
            for(int j=0;j<Table_hemi[i].nbr_element;j++){
                if(hemi[i].len_poly <= Table_hemi[i].num_bond[j]){
                    cout << "After initialization of hemi: There are some bonds here which are at higher positions than the length of the polymer." << endl;
                    cout << "Poly: " << i << "; len_poly: " << hemi[i].len_poly << "; num_bond: " << Table_hemi[i].num_bond[j] << endl;
                    exit(1);
                }
            }
        }
        a0 = 0;
        for(int i=0; i<Table_hemi.size();i++){
        	a0 += Table_hemi[i].prop_sum;
        }
        for(int i=0;i<Table_cellu.size();i++){
            a0 += Table_cellu[i].prop_sum;

        }
        a0 +=Table_lign.prop_sum;

        if(par.init_XYL > 0 and a0 <= 0){
        	cout << "Initialization of Table_hemi failed!" << endl;
        	exit(1);
        }
        cout << "Initialization of Table_hemi successful" << endl;
    }


    if(par.verbose == true){
        cout << "inhibition weight factors; EG: " << par.inhib_cellobiose_EG << "; CBH: " << par.inhib_cellobiose_CBH << "; BGL: " << par.inhib_glucose_BGL << endl;
        cout << "Initial number of reactions: " << reactionsOverall << endl;
    }


    //==================================== Print some information ==============================================
    if(par.verbose == true){
        cout << "Cellulose percentage: " << 100. * double(glcCelluBefore)/double(glcCelluBefore + xyloseOverall + lignolBefore)  << "%" << endl;
        cout << "Hemicellulose percentage: " << 100. * double(xyloseOverall)/double(glcCelluBefore + xyloseOverall + lignolBefore) << "%; This has a relative error of " << 100.*(double(xyloseOverall)/double(glcCelluBefore + xyloseOverall + lignolBefore) - par.pct_hemi)/(par.pct_hemi) << "% to the parameter value specified in the file, which is " << 100.*par.pct_hemi << "%" << endl;
        cout << "Lignin percentage: " << 100. * double(lignolBefore)/double(glcCelluBefore + xyloseOverall + lignolBefore) <<  "%; This has a relative error of " << 100.*(double(lignolBefore)/double(glcCelluBefore + xyloseOverall + lignolBefore) - par.pct_lign)/(par.pct_lign) << "% to the parameter value specified in the file, which is " << 100.*par.pct_lign << "%" << endl;
        //Estimation of  system volume
        m_fibril = (nbr_poly_cellu * (par.length_fibril+1))*(m_glc);
        m_fibril-= 2*nbr_poly_cellu*m_hydrogen;//Subtract the mass of the hydrogen lost due to bonding of glucose to each other; here for the end of the fibrils
        m_fibril -= 2*(par.length_fibril-2)*nbr_poly_cellu * m_hydrogen;

        double N_fibril = m_dry * (double(nbr_poly_cellu)/double(nbr_poly_cellu+nbr_poly_hemi+nbr_poly_lign)) / m_fibril;

        cout << "m_fibril = " << m_fibril << endl;
        cout << "N_fibril = " << N_fibril << endl;

        V_System = V_solution/(m_dry/m_fibril);
        cout << "Estimated volume of this system: " << V_System << endl;



        cout << "propensity sum at start: " << a0 << endl;
    }




    //================== Initialize some last variables =================================
    t0 = 0.;//Set step number tracker to 0


    //======================================================================================
    //============================  START GILLESPIE LOOP ===================================
    //======================================================================================

    cout<<"\n \n AVANT GILLESPIE LOOP \n \n"<<endl;

    while(t0<(par.T+par.Transient))//Max number of steps: par.T + par.Transient. However the simu will finish before if there are no more reactions to perform
    {

        check_for_blocked_ends(cellu,Table_cellu,par);//Check the blocking status of attached CBH enzymes

    	free_CBH_before = par.N_free_CBH;//Set number of free CBHs at start of step

    	if(par.enzyme_timer == 1){
			t_start_gillespie = high_resolution_clock::now();
    	}
    	reaction_count = 0.;
    	for(int i=0;i<Table_cellu.size();i++){
            reaction_count += Table_cellu[i].nbr_element;
    	}
    	for(int i=0;i<Table_hemi.size();i++){
    		reaction_count += Table_hemi[i].nbr_element;
    	}
    	if(reaction_count > 0)
	    	par.Nbr_reactions.push_back(reaction_count);



        //=========================== Take picture of DP distribution ===========================
        if(heatmap_bool == 1){
            if(int(t0) % par.DP_print_Freq == 0){

    	    	if(par.enzyme_timer == 1){
    				t_start = high_resolution_clock::now();
    	    	}

                DP_distrib.push_back(DPList(par.length_fibril+1));
                DP_distrib[DP_index].real_time = par.real_time;
                DP_distrib[DP_index].DP[0] = nbr_Glc_pdt;

                for(int i=0; i < cellu.size();i++){
                    DP_len_index = cellu[i].len_poly;//shifted by one to the left due to array placement
                    if(DP_len_index > 0){
                        if(DP_len_index < DP_distrib.at(DP_index).DP.size()){
                            DP_distrib.at(DP_index).DP[DP_len_index] += 1;

                    	}
                        else
                            cout << "DP_len_index > length_fibril!" << endl;
                    }
                }

                for(int i=0;i<DP_distrib[DP_index].DP.size();i++){
                	DP_distrib[DP_index].DP[i]*= i+1;
                	DP_distrib[DP_index].DP[i]/=glucoseOverall;
                }

                DP_index ++;
            }
        }



        //============== Calculate the overall glucose content of the system before applying the reaction of this step. ==============
        //============== This is a sanity check to see whether the glucose amount is conserved =======================================
        glcBefore = countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt;


        //Increase step number
        t0++;


        //================ Optional output ================
        if(par.verbose == true){
        	cout << "================================================" << endl;
            cout << "Step number " << t0 << endl;
            cout << "Glc released before: " << nbr_Glc_pdt << endl;
            cout << "Xyl released before: " << nbr_xyl_pdt << endl;
        }



        //Print progress to command line every ${printFreq} steps
        if(int(t0) % printFreq == 0){
            cout << "Step: " << t0 << "; glc released: " << nbr_Glc_pdt << "; xyl released: " << nbr_xyl_pdt << "; cellobiose in system: " << nbr_cellobiose  << "; real_time: " << par.real_time << endl;
        }


        if(t0>par.Transient && THRESHOLD==0)
        {
            time_Transient=par.real_time;//Real transient time
            THRESHOLD=1;
        }



        //Count cellobiose in system and check whether everything is in order
        if(par.verbose == true){
            if(nbr_cellobiose != countCellobiose(cellu)){
                cout << "nbr_cellobiose != countCellobiose(cellu)!!!!" << endl;
                cout << nbr_cellobiose << "\t" << countCellobiose(cellu)<< endl;
            }
            else
                cout << "nbr_cellobiose = " << countCellobiose(cellu) << endl;
        }



        //=========== Inhibition by glucose and cellobiose ==================
        //CURRENTLY NOT IMPLEMENTED UP-TO-DATE
        if(par.mode_inhib == 1 and (nbr_Glc_pdt > 0 or nbr_cellobiose > 0)){
            update_reactiontables_inhib(Table_cellu, cellu, Table_hemi, par, nbr_Glc_pdt, nbr_cellobiose, chem_entities);
            if(par.verbose == true){
                cout << "reactions updated" << endl;
            }
            for(int i=0; i<Table_cellu.size();i++)
                Table_cellu[i].calcTableProp();
            for(int i=0; i<Table_hemi.size();i++)
                Table_hemi[i].calcTableProp();
        }



        //========================= Re-calculate propensity sum =========================
        a0=0.;
        a0 +=Table_lign.prop_sum;
        for(int i=0;i<Table_cellu.size();i++)
            a0 += Table_cellu[i].prop_sum;
        for(int i=0;i<Table_hemi.size();i++)
        	a0 += Table_hemi[i].prop_sum;






        if(a0 < 0){
            cout << "In function run(): negative propensity(a0)!!!" << endl;
            exit(1);
        }
        if(par.verbose == true)
                cout << "a0 = " << a0 << endl;


        //============= Do some more checks =============================

        if(a0 == 0 or a0 == Table_lign.prop_sum){//Test whether there are any reactions left in reaction table                    //-------> partho comment
//          int non_cellobiose_glucose = countGlc(cellu,1) + countGlc(hemi,2) - 2*countCellobiose(cellu);
//	  if (non_cellobiose_glucose == 0 and a0 == 0 and a0 == Table_lign.prop_sum){                   // partho new check
            cout << "\n" << endl;
            cout << "====================================" << endl;
            cout << "Nothing more to digest. Stopping. real_time: " << par.real_time << "; step number: " << t0 << endl;
            int non_cellobiose_glucose = countGlc(cellu,1) + countGlc(hemi,2) - 2*countCellobiose(cellu);
            int remain_Cbs1 = countCellobiose(cellu);    //partho count remaining cellobiose
            int remain_xylose = countXyl(hemi);     // partho xylose remain check
            int remain_lignin = countLign(lign);    // partho lignin number check
            int remain_Glc = countGlc(cellu,1) + countGlc(hemi,2);      // partho glucose check
            int remain_Glc1 = countGlc(cellu,1);     // partho glucose remain in cellulose core
            int remain_Glc2 = countGlc(hemi,2);     // partho glucose remain in hemi
            int remain_Cbs2 = countCellobiose(hemi);     // partho count cellobiose in hemi
            cout << "====================================" << endl;
            cout << "non-cellobiose glucose remaining in fibril: " << non_cellobiose_glucose << endl;
            cout << "Glucose remaining in fibril: " << remain_Glc << endl; // partho print glucose remain in fibril;
            cout << "Glucose remaining in cellulose core: " << remain_Glc1 << endl; //  partho glucose remain in cellulose core
            cout << "Cellobiose remaining in cellulose core:  " << remain_Cbs1 << endl; // partho Cellobiose remain in cellu
           if (par.xyl_or_mlg == false){
                cout << "Glucose remaining in hemi:  " << remain_Glc2 << endl; //partho glucose remain in hemi
                cout << "Cellobiose(beta 1,3 linkage) from MLG remaining in hemi: " << remain_Cbs2 << endl; //partho Cellobiose remain in hemi
            }
            else if (par.xyl_or_mlg == true){
                cout << "Xylose remaining in fibril: " << remain_xylose << endl; // partho xylose remain print    
            }
            cout << "Lignin remaining in the fibril: " << remain_lignin << endl; // partho lignin remain print

            if(non_cellobiose_glucose > 0 and par.N_free_CBH > 0 and par.crystal_modifier_cellu > 0.0 and prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose) > 0){
                bool status_bool = false;
                for(int i=0;i<cellu.size();i++){
                    for(int j=0;j<cellu[i].len_poly;j++){
                        if(cellu[i].status[j] == 1){
                            status_bool = true;
                            break;
                        }

                    }
                }
                if(status_bool == true){
                	cout << "Non-cellobiose glucose remains, even though there are " << par.N_free_CBH << " free CBH enzymes around that should be able to digest it, and crystalline bonds should be digestible. The number of free ends is: " << par.N_free_ends << ", and the propensity of an attachment reaction woud be " << prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose) << ". Stopping program" << endl;
                    cout << "Reaction table dump: " << endl;
                    for(int i=0;i<Table_cellu.size();i++){
                        cout << "Length of polymer: " << cellu[i].len_poly << endl;
                        cout << "stati of bonds: " << endl;
                        for(int j=0;j<cellu[i].len_poly;j++){
                            cout << cellu[i].status[j] << ", ";
                        }
                        cout << endl;
                        Table_cellu[i].print_all_reactions();
                    }
                	exit(1);
                }
            }
            else if(non_cellobiose_glucose > 0 and par.N_free_CBH == 0 and par.CBH_enzymes.size() > 0){
            	cout << "Non-cellobiose glucose remains, and there are attached CBH enzymes. The reaction tables should not be empty. Stopping." << endl;
            	exit(1);
            }

            //======================= Optional: print remaining polymer bond positions to file ================
            if(par.verbose == true or par.print_polys == true){
                cout << "nbr_poly_cellu = " << nbr_poly_cellu << endl;
                ofstream remaining_cellu_file("Output/3D/remaining_cellu_" + to_string(current_run) + ".txt");
//                ofstream example_neighbor_file("Output/3D/neighbors_of_one_" + to_string(current_run) + ".txt");
                if(nbr_poly_cellu > 0){
                    for(int i=0; i<nbr_poly_cellu; i++){
                        for(int j=0; j<cellu[i].len_poly; j++){
                            remaining_cellu_file << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << "\t" << cellu[i].status[j] << "\t" << cellu[i].len_poly << endl;
                        }

                    }
                }
                remaining_cellu_file.close();
//                example_neighbor_file.close();

                ofstream remaining_hemi_file("Output/3D/remaining_hemi_" + to_string(current_run) + ".txt");
                for(int i=0;i<nbr_poly_hemi;i++){
                    for(int j=0; j<hemi[i].len_poly; j++){
                        remaining_hemi_file << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
                    }
                }
                remaining_hemi_file.close();
            }

            if(par.verbose == true){
                for(int i=0; i<cellu.size();i++){
                    for(int j=0; j<cellu[i].len_poly; j++){
                        if(cellu[i].status[j] == 1){
                            cout << "Nothing more to digest, but the status of at least one bond is 1! This should not happen. Stopping" << endl;
                            cout << "N_free_CBH = " << par.N_free_CBH << endl;
                            cout << "N_free_ends = " << par.N_free_ends << endl;
                            if(cellu[i].len_poly == 3){
                                if(par.free_poly_ends.find(cantor_pair_two(i,1)) != par.free_poly_ends.end()){
                                    cout << "The length of the corresponding poly is 3, and the end of this poly is in free ends" << endl;
                                }
                                else if(CBH_enzyme_attached(par,i,1) == true){
                                    cout << "The length of the corresponding poly is 3, and a CBH is attached." << endl;
                                }
                                else{
                                    cout << "The length of the corresponding poly is 3, and the end of this poly is NOT in free ends, and NO CBH is attached!" << endl;
                                }
                            }
                            exit(1);
//                            exit(1);
                        }
                        std::tuple<double,double,int> neighbor_key = std::make_tuple(cellu[i].x, cellu[i].y, cellu[i].z[j]);
                        int test10 = 0;
                        for(int k = 0; k < bond_neighbors_cellu[neighbor_key].N_neighbors; k++){
                            if(bond_neighbors_cellu[neighbor_key].scalar_products[k] > 0){
                                test10  = 1;
                            }
                            if(test10 == 0){
                                cout << "Scalar products smaller than or equal to zero, but no status 1 bonds!" << endl;
                                exit(1);
                            }
                        }
                    }
                }
            }
            if (t0 < outputBoundary)
                outputBoundary = t0-1;
            if(par.verbose == true){
                cout << "outputBoundary: " << outputBoundary << "; t0: " << t0 << endl;
            }
            break;
        }


        //======================================================================
        //============== Choose reaction and size of timestep ==================
        //======================================================================


        if(par.verbose == true){
        	cout << "Choosing reaction" << endl;
        }

        //Reset variables related to the chosen reaction
        mu1 = -1;
        table_selected = -1;
        poly_selected = -1;
        bond_selected = -1;
        action_mu1 = -1;
        substrate = -1;
        tau = -1.;

        //Pick the reaction and thereby set the above variables, which are given as references to the function pick_reaction()
        while(mu1 == -1){
            pick_reaction(par, Table_cellu,Table_hemi,Table_lign,cellu,hemi,lign,a0,reaction_table_sample,tau,mu1,table_selected,poly_selected,bond_selected,action_mu1, substrate);
        }



        par.real_time += tau;//Update the real time. The value of tau is calculated in the function pick_reaction()

        if(par.real_time >= par.max_time){
            cout << "==========================================" << endl;
            cout << "Simulation time ended; glucose released: " << nbr_Glc_pdt << "; xylose released: " << nbr_xyl_pdt << endl;
            return nbr_Glc_pdt;
        }


        if(par.enzyme_timer == 1){
			t_end = high_resolution_clock::now();
			duration = duration_cast<microseconds>(t_end - t_start);
			time_find_reaction.push_back(double(duration.count()));
        }


        //Optional: print information about the reaction that was chosen
        if(par.verbose == true){
        	if(substrate == 1){
            cout << "poly_selected: " << poly_selected << "; table_selected: " << table_selected << "; its size: " << Table_cellu[table_selected].nbr_element << " or " << Table_cellu[table_selected].liste_prop.size() << "; bond_selected: " << bond_selected << "; Length of polymer: " << cellu[poly_selected].len_poly << endl;
            cout << "enzyme: " << action_mu1 << "; substrate: " << substrate << "; Number of cellu polymers: " << cellu.size() << "; Number of associated reaction tables: " << Table_cellu.size() << "; propensity: " << *Table_cellu[table_selected].liste_prop[mu1] << endl;
            }
            else if(substrate ==2){
	            cout << "poly_selected: " << poly_selected << "; table_selected: " << table_selected << "; its size: " << Table_hemi[table_selected].nbr_element << " or " << Table_hemi[table_selected].liste_prop.size() << "; bond_selected: " << bond_selected << "; Length of polymer: " << hemi[poly_selected].len_poly << endl;
    	        cout << "enzyme: " << action_mu1 << "; substrate: " << substrate << "; Number of hemi polymers: " << hemi.size() << "; Number of associated reaction tables: " << Table_hemi.size() << endl;
            }
            else if(substrate == 0){
                cout << "glue!" << endl;
            }
            if(substrate == 1){
	            for(int i=0;i<Table_cellu[table_selected].nbr_element; i++){
	                if(Table_cellu[table_selected].indic_action[i] == 1 and par.init_EG == 0)
	                    cout << "EG digest action even though there is no EG in system" << endl;

	            }
            }
        }



        if(par.verbose == true){
        	if(substrate == 1){
	            cout << "reactions connected to this polymer: " << countReactions(Table_cellu[table_selected], poly_selected, error_bool) << endl;
                cout << "Reactions in detail:" << endl;
                Table_cellu[table_selected].print_all_reactions();
                cout << "====================================================" << endl;
            }
	        else if(substrate == 2)
	        	cout << "reactions connected to this polymer: " << countReactions(Table_hemi[table_selected], poly_selected, error_bool) << endl;

	        if(error_bool == 1)
	        	exit(1);
        }

        //=================================== Some more checking and optional printed information ====================
        if(par.verbose == true){
        	if(substrate ==1){
    	    	if(cellu[poly_selected].len_poly == 1){
    		        cout << "=======================================" << endl;
    		        cout << "len_poly = 1; prop_sum = " << Table_cellu[poly_selected].prop_sum << "; number of reactions: " << Table_cellu[poly_selected].liste_prop.size() << "\t" << Table_cellu[poly_selected].prop_uninhib.size() << "\t"\
    		         << "\t" << Table_cellu[poly_selected].liste_prop.size() << endl;
    		        cout << Table_cellu[poly_selected].nbr_element << endl;
    		         for(int o = 0; o<Table_cellu[poly_selected].indic_action.size();o++){
    		            cout << Table_cellu[poly_selected].index_poly << "\t" \
    		                << Table_cellu[poly_selected].num_bond[o] << "\t" \
    		                << Table_cellu[poly_selected].material[o] << "\t" \
    		                << Table_cellu[poly_selected].indic_action[o] << "\t" \
    		                << Table_cellu[poly_selected].liste_prop[o] << "\t" \
    		                << Table_cellu[poly_selected].prop_uninhib[o] << endl;
    		            }
    		        cout << "=======================================" << endl;
    	    	}
    	    }
         }


        //=================== Optional: take picture of the whole system =========================
        if(current_run != 0){
            if(countGlc(cellu,1) <= 4 or (t0<= par.T + par.Transient and int(t0)%par.pict_3D_Freq == 0))
            {
                // ================= 3D structure snapshot ===================
                if(vid == true and current_run == 1){
                	par.output_file = "Output/3D/bond_neighbor_visualization_cellu_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
                    ofstream bond_neighbor_file(par.output_file);
                    std::tuple<double,double,int> current_key = std::make_tuple(0.,0.,0);
                    for(int i=0; i<cellu.size(); i++){
                        for(int j=0; j<cellu[i].z.size(); j++){
                            current_key = std::make_tuple(cellu[i].x,cellu[i].y,cellu[i].z[j]);
                            // cout << "(" << cellu[i].x << ", " << cellu[i].y << ", " << cellu[i].z[j] << "): " << bond_neighbors_cellu[current_key].N_neighbors << endl;
                            bond_neighbor_file << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << "\t" << bond_neighbors_cellu[current_key].N_neighbors << endl;
                        }
                        bond_neighbor_file << "\n" << endl;
                    }
                    bond_neighbor_file.close();



                    //Builds the visualization ouput file of the fibril
					if(nbr_poly_cellu > 0){
					    par.output_file = "Output/3D/visualisation_cellu_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
	                    cout << par.output_file << endl;
	                    ofstream file52(par.output_file);
	                    //Output the structure of remaining cellulose
	                    for(int i=0; i<nbr_poly_cellu; i++)
	                    {
                            if(cellu[i].len_poly >= 1){ //partho all cellu including cbs are in video
    	                        for(int j=0; j<cellu[i].len_poly; j++)
    	                        {
    	                            if((cellu[i].status[j]==-1) or(cellu[i].status[j]==1))
    	                                file52<<cellu[i].x<<'\t'<<cellu[i].y<<'\t'<<cellu[i].z[j]<<'\t'<<cellu[i].index<<endl;
    	                        }
                            }
	                    }
	                    file52.close();
	                }


                    //Builds the visualization ouput file of ALL hemicellulose
                    if(nbr_poly_hemi > 0){
						par.output_file = "Output/3D/visualisation_hemi_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
                        cout << par.output_file << endl;
                        ofstream file62(par.output_file);
                        //Output the structure of all hemicellulose
                        for(int i=0; i<nbr_poly_hemi; i++)
                        {
                            if(hemi[i].len_poly >= 1){  //partho all cellu including cbs are in video
                                for(int j=0; j<hemi[i].len_poly; j++)
                                    file62<<hemi[i].x<<'\t'<<hemi[i].y<<'\t'<<hemi[i].z[j]<<endl;
                            }
                        }
                        file62.close();
                    }

                    if(nbr_poly_hemi > 0){
                    //Builds the visualization ouput file of hemicellulose acetylated
						par.output_file = "Output/3D/visualisation_hemi_acetylated_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
                        cout << par.output_file << endl;
                        ofstream file72(par.output_file);
                        //Output the structure of hemicellulose acetylated
                        for(int i=0; i<nbr_poly_hemi; i++)
                        {
                            for(int j=0; j<hemi[i].len_poly; j++)
                            {
                                if(hemi[i].status[j]==-2)
                                    file72<<hemi[i].x<<'\t'<<hemi[i].y<<'\t'<<hemi[i].z[j]<<endl;
                            }
                        }
                        file72.close();
                    }
                    cout << nbr_poly_lign << endl;
                    if(nbr_poly_lign > 0){
                        cout << "lign building" << endl;
                    //Builds the visualization ouput file of lignin
						par.output_file = "Output/3D/visualisation_lignin_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
                        cout << par.output_file << endl;
                        ofstream file82(par.output_file);
                        //Output the structure of lignin
                        for(int i=0; i<nbr_poly_lign; i++)
                        {
                            for(int j=0; j<lign[i].len_poly; j++)
                            	if(lign[i].covering[j] == true){
	                                file82<<lign[i].x<<'\t'<<lign[i].y<<'\t'<<lign[i].z[j]<<endl;
                            	}
                        }
                        file82.close();
                    }

                    // Record all the polymers in a single output file
                    if(nbr_poly_cellu > 0){
					    par.output_file = "Output/3D/visualisation_total_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
	                    cout << par.output_file << endl;
	                    ofstream file99(par.output_file);
	                    //Output the structure of remaining cellulose
	                    for(int i=0; i<nbr_poly_cellu; i++)
	                    {
                            if(cellu[i].len_poly >= 1){ //partho all cellu including cbs are in video
    	                        for(int j=0; j<cellu[i].len_poly; j++)
    	                        {
    	                            if((cellu[i].status[j]==-1) or(cellu[i].status[j]==1))
    	                                file99<<cellu[i].x<<'\t'<<cellu[i].y<<'\t'<<cellu[i].z[j]<<'\t'<< '2' <<'\t' << par.real_time << endl;
    	                        }
                            }
	                    }
	                    
	                    //Output the structure of remaining hemicellulose
	                    for(int i=0; i<nbr_poly_hemi; i++)
                        {
                            if(hemi[i].len_poly >= 1){  //partho all hemi including cbs are in video
                                for(int j=0; j<hemi[i].len_poly; j++)
                                    file99<<hemi[i].x<<'\t'<<hemi[i].y<<'\t'<<hemi[i].z[j]<<'\t'<< '1' <<'\t' << par.real_time << endl;
                            }
                        }
                        
                        //Output the structure of remaining lignin
                        for(int i=0; i<nbr_poly_lign; i++)
                        {
                            for(int j=0; j<lign[i].len_poly; j++)
                            	if(lign[i].covering[j] == true){
	                                file99<<lign[i].x<<'\t'<<lign[i].y<<'\t'<<lign[i].z[j]<<'\t' <<'0' << '\t' << par.real_time << endl;
                            	}
                        }

	                    file99.close();
	                }


                    // Print saccharification data progressively
                    if(nbr_poly_cellu > 0){
                        par.output_file = "Output/3D/conversion_" + to_string(current_run) + "_" + to_string(nbr_pict_taken) + ".txt";
                        cout << par.output_file << endl;
                        ofstream file666(par.output_file);
                        for(int i=0;i<par.time_mean.size();i++){
                            if(i<par.amount_glc_mean.size()){
                            file666 << par.time_mean[i] << "\t" << par.amount_glc_mean[i] << "\t" << par.amount_cellobiose_mean[i] << "\t" << par.amount_xylose_mean[i] << endl;
                            }
                        }    
                        file666.close();
                    }

                    
                    nbr_pict_taken++;
                }
            }
        }


        //Save output data for this step prior to performing the reaction
        par.amount_glc_mean.push_back(100. * nbr_Glc_pdt /(nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)));//glucan to glucose percentage
//        par.amount_glc_mean.push_back(nbr_Glc_pdt);//release in number of glucose monomers :partho
        par.amount_cellobiose_mean.push_back(100 * 2 * nbr_cellobiose/(nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)));//percentage of glucose in cellobiose
//        par.amount_cellobiose_mean.push_back(nbr_cellobiose);//Number of cellobiose: partho
        par.amount_xylose_mean.push_back(100 * nbr_xyl_pdt/(nbr_xyl_pdt + countXyl(hemi))); //xylose release in percentage
//        par.amount_xylose_mean.push_back(nbr_xyl_pdt); //xylose release number :partho

        par.EG_conc_mean.push_back(chem_entities[0]);
        par.CBH_conc_mean.push_back(chem_entities[1]);
        par.BGL_conc_mean.push_back(chem_entities[2]);
        par.XYL_conc_mean.push_back(chem_entities[3]);
        par.enzymes_glued.push_back(par.N_enzymes_glued);
        par.time_mean.push_back(par.real_time);

        if(par.print_CBH_positions == true and int(t0) % par.pict_3D_Freq == 0){
            nbr_CBH_pictures++;
            ofstream CBH_attachment_point_file("Output/3D/CBH_positions_" + to_string(current_run) + "_" + to_string(nbr_CBH_pictures) + ".txt");
            par.average_ends_occupied_by_CBH.push_back(0.);
            par.number_of_attached_CBH.push_back(par.CBH_enzymes.size()-par.N_free_CBH);
            if(par.N_free_CBH < par.CBH_enzymes.size()){
                for(int i=0;i<par.CBH_enzymes.size();i++){
                    if(par.CBH_enzymes[i].attached == true){
                        CBH_attachment_point_file << cellu[par.CBH_enzymes[i].poly_attached].x << "\t" << cellu[par.CBH_enzymes[i].poly_attached].y << "\t" << cellu[par.CBH_enzymes[i].poly_attached].z[par.CBH_enzymes[i].bond_attached] << endl;
                        par.average_ends_occupied_by_CBH[par.average_ends_occupied_by_CBH.size()-1] += par.CBH_enzymes[i].enzyme_neighbors.N_neighbors;
                    }
                }
                par.average_ends_occupied_by_CBH[par.average_ends_occupied_by_CBH.size()-1]/=(par.CBH_enzymes.size()-par.N_free_CBH);
            }
            CBH_attachment_point_file.close();
        }

        if(t0>0){

        	par.EG_activity.push_back(double(count_EG)/double(t0));
        	par.CBH_activity.push_back(double(count_CBH)/double(t0));
        	par.BGL_activity.push_back(double(count_BGL)/double(t0));
        	par.XYL_activity.push_back(double(count_xylanase)/double(t0));
            par.lign_activity.push_back(double(count_lignin_glue)/double(t0));

        }
        if(int(t0) % enzyme_activity_Freq == 0){//Fill enzyme_activity vectors
            check_reaction_table_distribution(Table_cellu,Table_hemi,Table_lign, par);
        }






        if (substrate == 1){//check length of polymer at the start of the step
            len_polyLoopStart = cellu[poly_selected].len_poly;
        }
        if (substrate == 2){
            len_polyLoopStart = hemi[poly_selected].len_poly;
        }


        //Sanity checks
        if(substrate == 1 and action_mu1 != 5){
            x_selected = cellu[poly_selected].x;
            y_selected = cellu[poly_selected].y;
            z_selected = cellu[poly_selected].z[bond_selected];
            if (cellu[poly_selected].crystalline[bond_selected] == true and par.crystal_modifier_cellu == 0){
                cout << "A CRYSTALLINE CELLU BOND IS BEING DIGESTED EVEN THOUGH THE CRYSTAL MODIFIER FACTOR IS 0. ABORTING" << endl;
                exit(1);
            }
        }
        else if(substrate == 2 and action_mu1 != 5){
            x_selected = hemi[poly_selected].x;
            y_selected = hemi[poly_selected].y;
            z_selected = hemi[poly_selected].z[bond_selected];
            if (hemi[poly_selected].crystalline[bond_selected] == true and par.crystal_modifier_hemi == 0){
                cout << "A CRYSTALLINE HEMI BOND IS BEING DIGESTED EVEN THOUGH THE CRYSTAL MODIFIER FACTOR IS 0. ABORTING" << endl;
                exit(1);
            }
        }




        //=====================================================================================================
        //==================================== PERFORM THE SELECTED REACTION ==================================
        //=====================================================================================================



        //=========================================================================================
        //==============================  Digestion by EG  ========================================
        //=========================================================================================
        if(action_mu1 != 1 and par.init_CBH == 0 and par.init_BGL == 0 and par.init_XYL == 0){
            cout << "action_mu1: " << action_mu1 << endl;
            cout << "There is only EG in the system, but a non_EG reaction was selected. Stopping..." << endl;
            exit(1);
        }

        if(action_mu1==1)
        {
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now();
        	}
            count_EG++;
            if(par.verbose == true)
                cout << "EG" << endl;

            /*If the material digested is cellulose*/
            if(substrate == 1){
//                if(bond_selected == 1 or bond_selected == cellu[poly_selected].len_poly-2)
//                    cout << "EG digest: bond number" << bond_selected << "; poly length: " << cellu[poly_selected].len_poly << endl;
//		cout << "PARTHO_check2" << endl;
                EG_digest(Table_cellu,cellu,hemi,par, Table_cellu, cellu, nbr_poly_cellu, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose,error_bool);
            }
            else if(substrate == 2){//This may happen later, when hemicellulose is updated to include sugars other than xylose
                cout << "EG reaction on hemi! This is currently not implemented. Stopping" << endl;
                exit(1);
                EG_digest(Table_cellu,cellu,hemi,par, Table_hemi, hemi, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            }

            if(par.enzyme_timer == 1){//Measure computation time taken
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_EG.push_back(double(duration.count()));
            }
        }


        //=========================================================================================
        //==============================  Digestion by CBH  =======================================
        //=========================================================================================

        if(action_mu1==2)
        {
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now();
        	}
            count_CBH++;
            if(par.verbose == true)
                cout << "CBH" << endl;

            if(substrate == 1)
                CBH_digest(Table_cellu,cellu,hemi,par, Table_cellu, cellu, nbr_poly_cellu, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            else if(substrate == 2){//This might occur later, when we include other sugars than xylose into the hemicellulose
                cout << "CBH reaction on hemi! This is currently not implemented. Stopping" << endl;
                exit(1);
                CBH_digest(Table_cellu,cellu,hemi,par, Table_hemi, hemi, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            }
            if(par.enzyme_timer == 1){//Measure computation time taken
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_CBH.push_back(double(duration.count()));
            }
        }




        //=========================================================================================
        //==============================  Digestion by BGL  =======================================
        //=========================================================================================

        if(action_mu1==3)
        {
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now();
        	}
            count_BGL++;
            if(par.verbose == true)
                cout << "BGL" << endl;

            if(substrate == 1)
                BGL_digest(par, Table_cellu, cellu, nbr_poly_cellu, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            else if(substrate == 2){//If we have other sugars than xylose in the hemicellulose
                cout << "BGL reaction on hemi! This is currently not implemented. Stopping" << endl;
                exit(1);
                BGL_digest(par, Table_hemi, hemi, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            }
            if(par.enzyme_timer == 1){//Measure computation time taken
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_BGL.push_back(double(duration.count()));
            }

        }

        //=========================================================================================
        //==============================  Digestion by XYL  =======================================
        //=========================================================================================


        if(action_mu1 == 4){
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now();
        	}
            count_xylanase++;
        	if(par.verbose == true){
        		cout << "XYL" << endl;
                for(int i=0;i<nbr_poly_hemi;i++){
                    for(int j=0;j<Table_hemi[i].nbr_element;j++){
                        if(Table_hemi[i].num_bond[j] >= hemi[i].len_poly){
                            cout << "Error: Table_hemi contains a reaction for a bond not contained in hemi" << endl;
                            cout << "Reaction: " << endl;
                            Table_hemi[i].print_reaction(j);
                            exit(1);
                        }
                    }
                }
            }
            if(par.verbose == true){
                int count_xyl_before = countXyl(hemi) + nbr_xyl_pdt;
                cout << "step number " << t0 << endl;
                XYL_digest(Table_cellu,cellu,hemi,par, Table_hemi, Table_cellu, hemi, cellu, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
                if(count_xyl_before != countXyl(hemi) + nbr_xyl_pdt){
                    cout << "In function XYL_digest: xylose number is not conserved. Stopping." << endl;
                    exit(1);
                }
            }
            else{
//                cout << "step number " << t0 << endl;
            	XYL_digest(Table_cellu,cellu,hemi,par, Table_hemi, Table_cellu, hemi, cellu, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            }

            if(par.enzyme_timer == 1){//Measure computation time taken
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_XYL.push_back(double(duration.count()));
            }
        }

        //=========================================================================================
        //==============================  Glueing by lignin  ======================================
        //=========================================================================================

        if(par.mode_lignin_glue == 1){
            if(action_mu1 == 5){
                count_lignin_glue++;
                lignin_glue(par, cellu,hemi, bond_neighbors_cellu, bond_neighbors_hemi, Table_cellu, Table_hemi,Table_lign, chem_entities, nbr_poly_lign,nbr_Glc_pdt,nbr_cellobiose);

            }
        }


        //=========================================================================================
        //==============================  Attachment of CBH  ======================================
        //=========================================================================================
        if(action_mu1 == 6){
        	if(par.N_free_CBH > 0 and Table_cellu[table_selected].covered[mu1] == false){
	            CBH_attachment(Table_cellu,cellu,hemi,par, Table_cellu, cellu, hemi, lign, nbr_poly_cellu, bond_selected, poly_selected, chem_entities, substrate, bond_neighbors_cellu, bond_neighbors_hemi, nbr_Glc_pdt,nbr_cellobiose);
        	}
            else if(Table_cellu[table_selected].covered[mu1] == true){
                cout << "CBH_attachment function was called for a bond that is covered. Stopping" << endl;
                exit(1);
            }
        	else{
		        cout << "CBH_attachment function was called, even though there are no free CBHs. This should not happen. Stopping" << endl;
		        cout << "Propensity of par.propensities[5] = " << par.propensities[5] << "; propensity of this reaction = " << *Table_cellu[table_selected].liste_prop[mu1] << endl;
                cout << "Propensity values in propensity vector: " << endl;
                for(int i=0;i<par.propensities.size();i++){
                    cout << par.propensities[i] << "; ";
                }
                cout << endl;
		        exit(1);
        	}
        }
//---------------------------------partho edit cbh attach on hemi-------------------------------//
 /*       if(action_mu1 == 6){
        	if(par.N_free_CBH > 0 and Table_hemi[table_selected].covered[mu1] == false){
	            CBH_attachment(par, Table_hemi, cellu, hemi, lign, nbr_poly_hemi, bond_selected, poly_selected, chem_entities, substrate, bond_neighbors_cellu, bond_neighbors_hemi);
        	}
            else if(Table_hemi[table_selected].covered[mu1] == true){
                cout << "CBH_attachment function was called for a bond that is covered. Stopping" << endl;
                exit(1);
            }
        	else{
		        cout << "CBH_attachment function was called, even though there are no free CBHs. This should not happen. Stopping" << endl;
		        cout << "Propensity of par.propensities[5] = " << par.propensities[5] << "; propensity of this reaction = " << *Table_hemi[table_selected].liste_prop[mu1] << endl;
                cout << "Propensity values in propensity vector: " << endl;
                for(int i=0;i<par.propensities.size();i++){
                    cout << par.propensities[i] << "; ";
                }
                cout << endl;
		        exit(1);
        	}
        }     */
//---------------------------------partho edit cbh attach on hemi-------------------------------//


        //Update the reaction tables
        if(action_mu1 != 5 and action_mu1 != 6){
            if(par.verbose == true){
                cout << "Updating reaction table" << endl;
            }
            update_reactiontables(cellu, hemi, lign, Table_cellu, Table_hemi, par, chem_entities, bond_neighbors_cellu, bond_neighbors_hemi, x_selected, y_selected, z_selected, substrate, poly_selected, bond_selected,nbr_Glc_pdt,nbr_cellobiose);
        }


        if(par.verbose == true){
            cout << "Getting past digest" << endl;
            cout << "Glc released now: " << nbr_Glc_pdt << endl;
            cout << "Sizes of neighbor tables: cellu: " << bond_neighbors_cellu.size() << "; hemi: " << bond_neighbors_hemi.size() << endl;
        }


        if (countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt != glcBefore){
            cout << "Glucose produced or consumed in a reaction of action_mu1 " << action_mu1 << ", polymer " << poly_selected << ", its length(cellu): " << len_polyLoopStart << ", and after digest: " << cellu[poly_selected].len_poly << ", substrate: " << substrate << endl;
            cout << "Bond selected: " << bond_selected << ", Loop number: " << t0 << endl;
            exit(1);
        }



        //======================= Check, whether a polymer has been completely digested, and if yes, erase the corresponding object. Also check whether a polymer now has length 3 and needs a free end


        if(substrate == 1){
            if(cellu[poly_selected].len_poly == 3){
                if(par.free_poly_ends.find(cantor_pair_two(poly_selected,1)) == par.free_poly_ends.end() and CBH_enzyme_attached(par,poly_selected,1) == false){
                    par.free_poly_ends.insert({cantor_pair_two(poly_selected,1),make_tuple(poly_selected,1)});
                    addreaction(Table_cellu,par,0,Table_cellu,poly_selected,1,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[poly_selected].crystalline[1]);//This already adds the corresponding reaction
                    par.N_free_ends++;
                }
            }
            if(action_mu1 == 1){
                if(cellu[cellu.size()-1].len_poly == 3){
                    if(par.free_poly_ends.find(cantor_pair_two(cellu.size()-1,1)) == par.free_poly_ends.end() and CBH_enzyme_attached(par,cellu.size()-1,1) == false){
                        par.free_poly_ends.insert({cantor_pair_two(cellu.size()-1,1),make_tuple(cellu.size()-1,1)});
                        addreaction(Table_cellu,par,0,Table_cellu,cellu.size()-1,1,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[cellu.size()-1].crystalline[1]);//This already adds the corresponding reaction
                        par.N_free_ends++;
                    }
                }
            }
            if(cellu[poly_selected].len_poly == 0){
                cellu.erase(cellu.begin()+poly_selected);
                Table_cellu.erase(Table_cellu.begin()+poly_selected);
                nbr_poly_cellu--;
                if(poly_selected < Table_cellu.size()){
                    for(int i=poly_selected; i< cellu.size();i++){//this iterates through cellu and Table_cellu, because they have the same size
                        for(int j=0; j<par.CBH_enzymes.size();j++){
                            if(par.CBH_enzymes[j].poly_attached == cellu[i].index){
                                par.CBH_enzymes[j].poly_attached = i;
                            }
                            if(par.CBH_enzymes[j].poly_attached == poly_selected){
                                par.CBH_enzymes[j].detach();
                                par.N_free_CBH++;
                            }
                        }
                        if(par.free_poly_ends.find(cantor_pair_two(cellu[i].index,1)) != par.free_poly_ends.end()){
                            par.free_poly_ends.erase(cantor_pair_two(cellu[i].index,1));
                            par.free_poly_ends.insert({cantor_pair_two(i,1),std::make_tuple(i,1)});
                            addreaction(Table_cellu,par,0,Table_cellu,i,1,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[i].crystalline[1]);//This already adds the corresponding reaction

                        }
                        if(par.free_poly_ends.find(cantor_pair_two(cellu[i].index,cellu[i].len_poly-2)) != par.free_poly_ends.end()){
                            par.free_poly_ends.erase(cantor_pair_two(cellu[i].index,cellu[i].len_poly-2));
                            par.free_poly_ends.insert({cantor_pair_two(i,cellu[i].len_poly-2),std::make_tuple(i,cellu[i].len_poly-2)});
                            addreaction(Table_cellu,par,0,Table_cellu,i,cellu[i].len_poly-2,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[i].crystalline[cellu[i].len_poly-2]);//This already adds the corresponding reaction
                        }
                        cellu[i].index = i;
                        Table_cellu[i].index_poly = i;

                    }

                }
                for(int i=0;i<par.CBH_enzymes.size();i++){
                    if(par.CBH_enzymes[i].poly_attached == poly_selected){
                        par.CBH_enzymes[i].detach();
                    }
                }
            }

        }
        else if(substrate == 2){
            if(hemi[poly_selected].len_poly == 0){
                hemi.erase(hemi.begin()+poly_selected);
                Table_hemi.erase(Table_hemi.begin()+poly_selected);
                nbr_poly_hemi--;
                if(poly_selected < Table_hemi.size()){
                    for(int i=poly_selected; i < hemi.size();i++){//this iterates through hemi and Table_hemi, because they have the same size
                        hemi[i].index = i;
                        Table_hemi[i].index_poly = i;
                    }
                }
            }

        }
        if(par.enzyme_timer == 1){
			t_end_gillespie = high_resolution_clock::now();
			duration = duration_cast<microseconds>(t_end_gillespie - t_start_gillespie);
			time_per_gillespie_step.push_back(double(duration.count()));
        }




        //=========================== Check, if a CBH enzyme has exceeded its attachment duration or is wrongly attached ================================
        if(par.verbose == true){
            cout << "Checking if a CBH has exceeded its attachment_duration or is attached to cellobiose" << endl;
        }
        for(int i=0; i<par.CBH_enzymes.size();i++){
            if(par.CBH_enzymes[i].attached == true){

                if(par.CBH_enzymes[i].poly_attached > cellu.size()){
                    cout << "CBH enzyme is attached to a poly that does not exist. Stopping." << endl;
                    exit(1);
                }
                if(par.CBH_enzymes[i].bond_attached != 1){
                    if(cellu[par.CBH_enzymes[i].poly_attached].len_poly != 1 and cellu[par.CBH_enzymes[i].poly_attached].len_poly != 3){
                        if(par.CBH_enzymes[i].bond_attached != cellu[par.CBH_enzymes[i].poly_attached].len_poly-2){
                            cout << "par.CBH_enzymes[i].bond_attached != len_poly-2 and != 1" << endl;
                            exit(1);
                        }
                    }
                }


                if(cellu[par.CBH_enzymes[i].poly_attached].len_poly-2 != par.CBH_enzymes[i].bond_attached and par.CBH_enzymes[i].bond_attached != 1){
                    cout << "A CBH enzyme is attached to the wrong bond. Bond: " << par.CBH_enzymes[i].bond_attached << "; len_poly = " << cellu[par.CBH_enzymes[i].poly_attached].len_poly << endl;

                    cout << "Checking the reaction table for a reaction at the wrong bond: " << endl;
                    bool found_reaction = false;
                    int found_reaction_index = -1;
                    for(int j=0;j<Table_cellu[par.CBH_enzymes[i].poly_attached].nbr_element;j++){
                        if(Table_cellu[par.CBH_enzymes[i].poly_attached].indic_action[j] == 2){
                            found_reaction = true;
                            found_reaction_index = Table_cellu[par.CBH_enzymes[i].poly_attached].num_bond[j];
                            Table_cellu[par.CBH_enzymes[i].poly_attached].print_reaction(j);
                            break;
                        }
                    }
                    if(found_reaction == false){
                        cout << "No reaction found." << endl;
                        par.CBH_enzymes[i].detach();
                        par.N_free_CBH++;
                    }
                    else{
                        cout << "reaction found." << endl;
                        par.CBH_enzymes[i].bond_attached = found_reaction_index;
                        //exit(1);
                    }
                }
                else if(cellu[par.CBH_enzymes[i].poly_attached].len_poly == 1){//No CBH should be attached to cellobiose
                    deletereaction(Table_cellu[par.CBH_enzymes[i].poly_attached],Table_cellu,1,par.CBH_enzymes[i].poly_attached,par.CBH_enzymes[i].bond_attached,2);
                    //no free poly end is inserted here
                    par.CBH_enzymes[i].detach();
                    par.N_free_CBH++;
                }
                else if(par.real_time >= par.CBH_enzymes[i].attachment_time + par.CBH_enzymes[i].attachment_duration){//Detach enzyme, because it has exceededs its attachment time
                    if(par.verbose == true and false){
                        cout << "Deleting reaction" << endl;
                    }
                    if(par.verbose == true){
	                    cout << "real_time = " << par.real_time << "; attachment_time = " << par.CBH_enzymes[i].attachment_time << "; attachment duration: " << par.CBH_enzymes[i].attachment_duration << endl;
	                    cout << "time + duration = " << par.CBH_enzymes[i].attachment_time + par.CBH_enzymes[i].attachment_duration << endl;
                    }
                    deletereaction(Table_cellu[par.CBH_enzymes[i].poly_attached],Table_cellu,1,par.CBH_enzymes[i].poly_attached,par.CBH_enzymes[i].bond_attached,2);

                    if(par.verbose == true and false){
                        cout << "Deleted reaction" << endl;
                    }
                  //  if(par.CBH_enzymes[i].bond_attached == 1 or par.CBH_enzymes[i].bond_attached == cellu[par.CBH_enzymes[i].poly_attached].len_poly-2){
                    par.free_poly_ends.insert({cantor_pair_two(par.CBH_enzymes[i].poly_attached,par.CBH_enzymes[i].bond_attached), make_tuple(par.CBH_enzymes[i].poly_attached,par.CBH_enzymes[i].bond_attached)});
                    par.N_free_CBH++;
                    if(true){
	                    addreaction(Table_cellu,par,0,Table_cellu,par.CBH_enzymes[i].poly_attached,par.CBH_enzymes[i].bond_attached,1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[par.CBH_enzymes[i].poly_attached].crystalline[par.CBH_enzymes[i].bond_attached]);//This already adds the corresponding reaction
                    }
                    par.N_free_ends++;
                //    }
                    par.CBH_enzymes[i].detach();
                }
            }
        }


        if(par.verbose == true){
            cout << "Checking, if all bonds in free_poly_ends exist, are free of CBH, and are at the right positions" << endl;
            for(int i=0;i<par.free_poly_ends.size();i++){
                auto it = std::next(std::begin(par.free_poly_ends), i);
                if(par.free_poly_ends.count(it->first) > 1){
                    cout << "A free_poly_end is contained in par.free_poly_ends more than once." << endl;
                    exit(1);
                }
                else if(get<1>(it->second) != cellu[get<0>(it->second)].len_poly-2 and get<1>(it->second) != 1){
                    cout << "A bond in free_poly_ends is wrong: " << endl;
                    cout << "Poly: " << get<0>(it->second) << "; bond: " << get<1>(it->second) << "; len_poly = " << cellu[get<0>(it->second)].len_poly << endl;
                    exit(1);
                }
                else{
                	if(true){
                		addreaction(Table_cellu,par,0,Table_cellu,get<0>(it->second),get<1>(it->second),1,6,prop(cellu,hemi,bond_neighbors_cellu,bond_neighbors_hemi,par,6,chem_entities,nbr_Glc_pdt,nbr_cellobiose),cellu[Table_cellu,get<0>(it->second)].crystalline[Table_cellu,get<1>(it->second)]);
                	}
                }
            }
        }

        if(par.verbose == true){
            cout << "Checking if more than two CBHs are attached to any polymer" << endl;
            int count_CBHs = 0;
            for(int i=0; i<cellu.size();i++){
                count_CBHs = 0;
                for(int j=0 ;j<par.CBH_enzymes.size();j++){
                    if(par.CBH_enzymes[j].poly_attached == i){
                        count_CBHs++;
                    }
                    if(count_CBHs > 2){
                        cout << "More than two CBHs are attached to the same polymer. This should never happen. Stopping" << endl;
                        exit(1);
                    }

                }
            }
        }

        if(par.verbose == true){
            cout << "Checking if CBH enzymes need to be distributed" << endl;
            cout << "par.N_free_CBH = " << par.N_free_CBH << endl;
        }


        int count_free_CBH = par.CBH_enzymes.size();
        for(int i=0; i<par.CBH_enzymes.size();i++){
            if(par.CBH_enzymes[i].attached == true){
                count_free_CBH--;
            }
        }
        if(par.verbose == true){
            cout << "counted free CBH = " << count_free_CBH << endl;
        }
        if(count_free_CBH != par.N_free_CBH){
        	cout << "Unaccounted for free CBHs. Last polymer digested was: " << poly_selected << "; its length now: ";
        	if(action_mu1 == 3){
        		cout << "0; last action_mu1 = 3" << endl;
        	}
        	else if(action_mu1 != 4){
	        	cout << cellu[poly_selected].len_poly << "; action_mu1 = " << action_mu1;
	        	if(action_mu1 == 2 or action_mu1 == 1){
	        		cout << "; Length of new polymer: " << cellu[cellu.size()-1].len_poly << endl;
	        	}
        	}
        	else{
        		cout << "XYL REACTION" << endl;
        	}
        	exit(1);
        }
//        par.N_free_CBH = count_free_CBH;

        //=========================================================================================================
        //Check if we need to remove CBH attachment reactions =====================================================
        //=========================================================================================================


        update_attachment_reactions(par, cellu, hemi, bond_neighbors_cellu, bond_neighbors_hemi, Table_cellu, chem_entities, nbr_Glc_pdt,nbr_cellobiose);

        if(par.N_free_CBH < 0){
        	cout << "N_free_CBH < 0. This should never happen. Stopping..." << endl;
        	exit(1);
        }
    //=======================================================================================
    //=============== END of the Gillespie loop =============================================
    //=======================================================================================


    }//This bracket ends the loop


    //============================================================
    //==================== Wrap up ===============================
    //============================================================



    if(par.verbose == true){
        cout << "At the end of the loop: glucose left in fibril: " << countGlc(cellu, 1) << "; xylose left in firbil: " << countXyl(hemi) << endl;
    }


//========================= Calculate average time taken for each enzyme function =================================
	if(par.enzyme_timer == 1){
		double mean_time;
		if(time_EG.size()>0){
			mean_time = 0;
			ofstream EG_timer_file("Output/time_EG.txt");
			for(int i=0;i<time_EG.size();i++){
				mean_time += time_EG[i]/double(time_EG.size());
				EG_timer_file << i << "\t" << time_EG[i] << endl;
			}
			EG_timer_file.close();
			cout << "Average time taken by function EG_digest: " << mean_time << " microseconds" << endl;
		}
		if(time_CBH.size()>0){
			mean_time = 0;
			ofstream CBH_timer_file("Output/time_CBH.txt");
			for(int i=0;i<time_CBH.size();i++){
				mean_time += time_CBH[i]/double(time_CBH.size());
				CBH_timer_file << i << "\t" << time_CBH[i] << endl;
			}
			CBH_timer_file.close();
			cout << "Average time taken by function CBH_digest: " << mean_time << " microseconds" << endl;
		}
		if(time_BGL.size()>0){
			mean_time = 0;
			ofstream BGL_timer_file("Output/time_BGL.txt");
			for(int i=0;i<time_BGL.size();i++){
				mean_time += time_BGL[i]/double(time_BGL.size());
				BGL_timer_file << i << "\t" << time_BGL[i] << endl;
			}
			BGL_timer_file.close();
			cout << "Average time taken by function BGL_digest: " << mean_time << " microseconds" << endl;
		}
		if(time_XYL.size()>0){
			mean_time = 0;
			ofstream XYL_timer_file("Output/time_XYL.txt");
			for(int i=0;i<time_XYL.size();i++){
				mean_time += time_XYL[i]/double(time_XYL.size());
				XYL_timer_file << i << "\t" << time_XYL[i] << endl;
			}
			XYL_timer_file.close();
			cout << "Average time taken by function XYL_digest: " << mean_time << " microseconds" << endl;
		}
		if(time_find_reaction.size()>0){
			mean_time = 0;
			ofstream find_reaction_timer_file("Output/time_find_reaction.txt");
			for(int i=0;i<time_find_reaction.size();i++){
				mean_time += time_find_reaction[i]/double(time_find_reaction.size());
				find_reaction_timer_file << i << "\t" << time_find_reaction[i] << endl;
			}
			find_reaction_timer_file.close();
			cout << "Average time taken to find a reaction inside the table: " << mean_time << " microseconds" << endl;
		}
		if(time_per_gillespie_step.size()>0){
			mean_time = 0;
			ofstream time_per_gillespie_step_timer_file("Output/time_per_gillespie_step.txt");
			for(int i=0;i<time_per_gillespie_step.size();i++){
				mean_time += time_per_gillespie_step[i]/double(time_per_gillespie_step.size());
				time_per_gillespie_step_timer_file << i << "\t" << time_per_gillespie_step[i] << endl;
			}
			time_per_gillespie_step_timer_file.close();
			cout << "Average time taken per gillespie step: " << mean_time << " microseconds" << endl;
		}
	}



    if(par.verbose == true){
        cout << "Glucose in cellu: " << countGlc(cellu,1) << "; glucose in hemi: " << countGlc(hemi,2) << "; xylose in hemi: " << countXyl(hemi) << "; glucose relased: " << nbr_Glc_pdt << "; xylose released: " << nbr_xyl_pdt << endl;
    }

    //Check again whether the glucose amount is conserved
    if(glucoseOverall - (nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)) == 0 and xyloseOverall - (nbr_xyl_pdt + countXyl(hemi)) == 0){
        if(par.verbose == true){
            cout << "==== Everything appears to be working; glucose produced: " << nbr_Glc_pdt << "; xylose produced: " << nbr_xyl_pdt << " ====" << endl;
        }
    }
/* Partho comment*/
    else{
        if(glucoseOverall - (nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)) != 0 and xyloseOverall - (nbr_xyl_pdt + countXyl(hemi)) != 0){
            cout << "WE ARE EITHER LOSING MONOMERS OR PRODUCING THEM FROM NOTHING!" << endl;
            exit(1);
        }
        else if(xyloseOverall - (nbr_xyl_pdt + countXyl(hemi)) != 0){
            cout << "WE ARE EITHER LOSING XYLOSE OR PRODUCING IT FROM NOTHING!" << endl;
            exit(1);
        }
        else if(nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2) != 0){
            cout << "WE ARE EITHER LOSING XYLOSE OR PRODUCING IT FROM NOTHING!" << endl;
            exit(1);
        }
    } //*/ //partho comment

    cout << "====================================" << endl;
    printf("DONE!\n");
//    drawPolys(cellu);

    if(verbose == true){
        cout << "Before clearing the neighbor maps, their sizes are: cellu: " << bond_neighbors_cellu.size() << "; hemi: " << bond_neighbors_hemi.size() << endl;
    }


    //Clear neighbors and reset nbr_poly_foo
    bond_neighbors_cellu.clear();
    bond_neighbors_hemi.clear();
    nbr_poly_cellu = 0;
    nbr_poly_hemi = 0;
    nbr_poly_lign = 0;

    cout << "====================================" << endl;
    cout << "Final glucose in system: " << nbr_Glc_pdt << "; final cellobiose in system: " << nbr_cellobiose << "; final xylose in system: " << nbr_xyl_pdt << endl;


    auto t_end_of_run = high_resolution_clock::now();

//    string final_time_string = time_string.str();
    string duration_of_run = to_string(chrono::duration<double>(t_end_of_run - t_start_of_run).count()) + " s";

    cout << "====================================" << endl;
    cout << "This simulation took " << duration_of_run << " of computation time" << endl;
    if(par.print_time == true){
        ofstream time_file("Output/time/time_" + to_string(current_run) + ".txt");
        time_file << current_run << "\t" << duration_of_run << endl;
        time_file.close();
    }


    return nbr_Glc_pdt;//Returns the number of glucose monomers released from the microfibril at the end of the simulation


    //END OF FUNCTION
}
