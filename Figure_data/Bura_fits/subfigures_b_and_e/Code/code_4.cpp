#include <cstdio>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <time.h>
#include <cstdlib>
#include <ctime>
#include <iomanip>
#include <string>
#include <string.h>
#include <list>
#include <algorithm>
#include <functional>
#include <math.h>
#include <sys/time.h>
#include "functions.hpp"
#include "structs.hpp"
#include <chrono>
#include <cmath>
#include <unordered_map>

using   namespace  std;
using std::ifstream;
using std::ofstream;
using std::ios;
using namespace std::chrono; 


//Declare running function
//Runs the gillespie algorithm. See below main() for more details
double run(bool verbose, bool randomSeed, bool vid, bool heatmap_bool, long int seed48, long int seed, const int sim_number, int& outputBoundary, vector<DPList>& DP_distrib, params& par);


//======================================================================================
//================== Other functions are defined in a separate file ====================
//======================================================================================






//===========================================================================================================================================================
//================================================================= MAIN ====================================================================================
//===========================================================================================================================================================
int main(int argc, char *argv[]){

//    exit(1);
				//======================================================================================
				//====== Declaration of variables which will not be contained in a "params" struct======
				//======================================================================================
  

    int sim_number = 1;//Used for enumeration of output files
    int outputBoundary = 0; //index up to which the mean values for glc, cellobiose and time will be output for DP_distrib
    int current_run = 1;//this counts the number of done runs in while loop

    long int seed = 158593303967;//seed of random generator if it is fixed
    long int seed48 = 158593303967;//seed of random generator if it is fixed

    double mean = 0;//Average saccharification yield over all runs



		    //========================== Boolean values connected to keyboard input ==========================
   
    //Keep in mind: true = 1, false = 0
    bool multiOutput = 1; // If this is set to 1, an output file will be generated for every outputlimiter-th run
    bool vid = 0; // If this is set to 1, files for a 3D video of the degradation process will be created. Beware, this takes a while!
    bool verbose = 0;//If this is set to 1, an increased number of progress messages will be printed
    bool randomSeed = 1;//If this is set to 1, the seed of the random generators will vary. Otherwise it will stay the same during each run()
    bool enzyme_timer = 0;//If this is set to 1, the time each digestion take is tracked and printed at the end of the run
    bool heatmap_bool = 0;//If this is set to 1, a (potentially large) file will be generated, which contains the degree-of-polymerization(DP) distribution during each simulation step
    bool output_bool = 1;//If this is set to 0, no output will be generated by the code. Mainly for debugging purposes


  	//============================= Command line arguments ====================================================
    if(argc > 1){
        for(int i=0;i<argc;i++){
            cout << argv[i] << endl;
            if(! strcmp(argv[i], "-verbose")){
                cout << "verbose" << endl;
                verbose = 1;
            }
            else if(! strcmp(argv[i], "-fixed_seed")){
                cout << "Fixed seed" << endl;
                randomSeed = 0;
            }
            else if(! strcmp(argv[i], "-vid")){
                cout << "vid" << endl;
                vid = 1;
            }
            else if(! strcmp(argv[i], "-timer")){
            	cout << "Timer for enzyme functions is on" << endl;
            	enzyme_timer = 1;
            }
            else if(! strcmp(argv[i], "-heatmap")){
                cout << "Data for heatmap will be generated" << endl;
                heatmap_bool = 1;
            }
            else if(! strcmp(argv[i], "-suppress_output")){
                cout << "No output will be generated" << endl;
                output_bool = false;
            }
        }
    }


    string line;//For reading input files
    params par;//This is where most parameters and variables are stored, in order to make them accessible from within functions. See structs.hpp
    par.initialize();//Initialize object par

    //Provide object par with those values which have already been specified
    par.verbose = verbose;
    par.DP_print_Freq = 1;//Determines, how often the DP-distribution of the system is screened. If set to 1e2, this is done every 100th step 
    par.enzyme_timer = enzyme_timer;

    // Check whether the initial configuration parameters should be taken from a file other than "initial_configuration_parameters.txt"

	if(argc > 1){
        sprintf(par.str9,"%d",sim_number);
        memset(par.output_file, 0, sizeof(par.output_file));
        strcat(par.output_file, "initial_configuration_parameters");
        if(argc > 1){
            strcat(par.output_file, "_");
            strcat(par.output_file, argv[1]);
        }
        strcat(par.output_file, ".txt");
        par.initConfigParams = par.output_file;
	/*	cout << "Changing initial_configuration_parameters filename" << endl;
		if(! strcmp(argv[1], "low")){
			par.initConfigParams = "initial_configuration_parameters_low";
		}
		else if(! strcmp(argv[1], "medium")){
			par.initConfigParams = "initial_configuration_parameters_medium";
		}
		else if(! strcmp(argv[1], "high")){
			par.initConfigParams = "initial_configuration_parameters_high";
		}*/
	}



//=========================================================================================//
//============================== Read input parameters files ==============================//
//=========================================================================================//


//============================== Read simulation parameters ===============================//
    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.simuParams.c_str());
    strcat(par.input_file, ".txt");
    ifstream file0(par.input_file);
    line.clear();


    if(file0)
    {
        getline(file0,line);
        istringstream in(line);
        in >> par.T >> par.Transient >> par.Nbr_picts >> par.max_time >> par.pict_3D_Freq >> par.Run_number >> par.mode_code >> par.mode_hemi >> par.mode_lign >> par.mode_inhib >> par.mode_lignin_glue >> par.mode_hemi_structure >> par.mode_enzyme_size >> par.Nruns >> par.enzyme_radius;
    }
    else{
        cout << "simulation_parameters.txt does not exist in the folder Params/ . Exiting." << endl;
        exit(1);
    }
    if(vid == true){
        cout << "pict_3D_Freq = " << par.pict_3D_Freq << endl;
    }
    if(par.T + par.Transient <= 0){
        cout << "The sum of T and Transient must be greater than 0. Please correct this in simulation_parameters.txt. Aborting." << endl;
        exit(1);
    }
    if(par.Nbr_picts < 0){
        cout << "Nbr_picts must be 0 or greater. Please correct this in simulation_parameters.txt. Aborting." << endl;
        exit(1);
    }
    if(par.max_time <= 0){
        cout << "max_time must be greater than 0. Please correct this in simulation_parameters.txt. Aborting." << endl;
        exit(1);
    }
    if(par.Run_number < 0){
        cout << "Run_number must be equal to or greater than 0. Please correct this in simulation_parameters.txt. Aborting." << endl;
        exit(1);
    }


    

    par.V_enzyme = 4.*M_PI*par.enzyme_radius*par.enzyme_radius*par.enzyme_radius/3.;


    // ====================== Check outputBoundary
    if(outputBoundary == 0)
        outputBoundary = par.Nbr_picts;



    //Also used for reading parameter files 
    sprintf(par.str5,"%d",sim_number);
    sprintf(par.str6,"%d",par.mode_code);
    sprintf(par.str7,"%d",par.mode_hemi);
    sprintf(par.str8,"%d",par.mode_lign);


    //==================================== Read initial configuration parameters =========================


    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.initConfigParams.c_str());
    cout << par.input_file << endl;

    ifstream file2(par.input_file);
/*    if(myFile.fail()){
        //File does not exist code here
    }*/

    line.clear();
    if(file2)
    {
        getline(file2,line);
        istringstream in(line);
        in >> par.init_EG >> par.init_CBH >> par.init_BGL >> par.init_XYL >> par.length_fibril >> par.pct_xyl >> par.pct_hemi >> par.pct_lign >> par.pct_acetyl_hemi >> par.pct_crystalline_cellu >> par.pct_crystalline_hemi >> par.r_monomer;

        cout << par.init_EG << "\t" << par.init_CBH << "\t" << par. init_BGL << "\t" << par.init_XYL << "\t" << par.length_fibril << "\t" << par.pct_xyl << "\t" << par.pct_hemi << "\t" << par.pct_lign << "\t" << par.pct_acetyl_hemi << endl;

    }
    else{
        cout << "initial_configuration_parameters.txt does not exist. Exiting." << endl;
        exit(1); 
    }

//============================== Check whether there are problems with the configuration parameters ===============================//

    if(par.length_fibril <= 0){
    	cout << "=============================================================================================" << endl;
        cout << "Length of fibril is 0 or negative. Please Change this in ’initial_configuration_parameters.txt’" << endl;
    	cout << "=============================================================================================" << endl;
        exit(1);
    }
    if(par.init_EG <= 0 and par.init_CBH <= 0 and par.init_BGL <= 0 and par.init_XYL <= 0){
    	cout << "=============================================================================================" << endl;
    	cout << "No enzymes in system, or negative concentrations. Nothing will be digested. Please adjust initial enzyme concentrations in ’initial_configuration_parameters.txt’" << endl;
    	cout << "=============================================================================================" << endl;
    	exit(1);
    }

    if(par.pct_lign > 1 or par.pct_hemi > 1 or par.pct_xyl > 1 or par.pct_acetyl_hemi > 1 or par.pct_lign < 0 or par.pct_hemi < 0 or par.pct_xyl < 0 or par.pct_acetyl_hemi < 0){
    	cout << "=============================================================================================" << endl;
    	cout << "One or more of the percentages in ’initial_configuration_parameters.txt’ is greater than 1 or less than 0. Please correct this and restart." << endl;
    	cout << "=============================================================================================" << endl;
    	exit(1);
    }


    cout << "Length of each fibril: " << par.length_fibril << endl;



    //==================================== Read kinetic parameters ==================================



    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.kinParams.c_str());
    strcat(par.input_file, ".txt");

    ifstream file3(par.input_file);
    line.clear();
    if(file3)
    {
        getline(file3,line);
        istringstream in(line);
        in >> par.k1 >> par.k2 >> par.k3 >> par.k4 >> par.k5 >> par.inhib_cellobiose_EG >> par.inhib_cellobiose_CBH >> par.inhib_glucose_BGL >> par.crystal_modifier_cellu >> par.crystal_modifier_hemi ;

    }
    else{
    cout << "kinetic_parameters.txt does not exist in the folder Params/ . Exiting." << endl;
    exit(1);
    }
    if(par.k1 < 0){
        cout << "Please enter a non-negative k1 in the file kinetic_parameters.txt" << endl;
        exit(1);
    }
    if(par.k2 < 0){
        cout << "Please enter a non-negative k2 in the file kinetic_parameters.txt" << endl;
        exit(1);
    }
    if(par.k3 < 0){
        cout << "Please enter a non-negative k3 in the file kinetic_parameters.txt" << endl;
        exit(1);
    }
    if(par.k4 < 0){
        cout << "Please enter a non-negative k4 in the file kinetic_parameters.txt" << endl;
        exit(1);
    }
    if(par.inhib_cellobiose_EG < 0){
        cout << "Please enter a non-negative inhib_cellobiose_EG in the file kinetic_parameters.txt" << endl;
        exit(1);
    }
    if(par.inhib_cellobiose_CBH < 0){
        cout << "Please enter a non-negative inhib_cellobiose_CBH in the file kinetic_parameters.txt" << endl;
        exit(1);
    }
    if(par.inhib_glucose_BGL < 0){
        cout << "Please enter a non-negative inhib_glucose_BGL in the file kinetic_parameters.txt" << endl;
        exit(1);
    }

    //========================= DONE READING INPUT FILES =======================





    //======================== Build vector for keeping track of DP distribution

    int timePoints = int((par.T+par.Transient)/par.DP_print_Freq);
    DPList size_example = DPList(par.length_fibril);
//    DPList *DP_distrib = new DPList[timePoints];
    vector<DPList> DP_distrib;





	//========================================================================
    //========================== Gillespie run(s) ============================
    //========================================================================
    
    while( current_run < par.Nruns+1){//This runs as often as 

        current_run++;

        cout << "Simu and seed number " << current_run << endl;

	    if(par.enzyme_radius == 0)
	        par.free_bonds_req = 1;
	    else{
	        par.free_bonds_req = free_bonds(par.enzyme_radius, par.mode_code);
	    }


        //This parameters have been included but have no function yet
        cout << "Enzyme size: " << par.enzyme_radius << endl;
        cout << "Required free neighbors: " << par.free_bonds_req << endl;

        //=========================================================================================================================================
        //================= Here the run() function is called an the Gillespie algorithm actually takes place ===================================
		//=========================================================================================================================================
        mean += (run(verbose,randomSeed,vid,heatmap_bool, seed48, seed, sim_number, outputBoundary, DP_distrib, par))/double(par.Nruns);

        cout << "Returned from run()" << endl;



        //=====================================================================================================================
        //=================================== Generate and fill output files===================================================
		//=====================================================================================================================

        
      	if(output_bool == true){
		    if(par.time_mean.size() > 0){
			    sprintf(par.str9,"%d",sim_number);
		        memset(par.output_file, 0, sizeof(par.output_file));
		        strcat(par.output_file, par.outputFileDir.c_str());                    
		        strcat(par.output_file, "saccharification/saccharification_");
		        if(argc > 1){
			        strcat(par.output_file, argv[1]);
			        strcat(par.output_file, "_");
		        }
		        strcat(par.output_file, par.str9);
			    strcat(par.output_file, ".txt");
    		    ofstream meanFile(par.output_file);
    		    meanFile << par.time_mean[0] << "\t" << par.amount_glc_mean[0] << "\t" << par.amount_cellobiose_mean[0] << "\t" << par.amount_xylose_mean[0] << endl;
    		    for(int i=1;i<par.time_mean.size();i++){
    		        if(i<par.amount_glc_mean.size())
    		            meanFile << par.time_mean[i] << "\t" << par.amount_glc_mean[i] << "\t" << par.amount_cellobiose_mean[i] << "\t" << par.amount_xylose_mean[i] << endl;
    		    }
    		    meanFile.close();


                sprintf(par.str9,"%d",sim_number);
                memset(par.output_file, 0, sizeof(par.output_file));
                strcat(par.output_file, par.outputFileDir.c_str());                    
                strcat(par.output_file, "enzyme_concentration/enzyme_concentration_");
                if(argc > 1){
                    strcat(par.output_file, argv[1]);
                    strcat(par.output_file, "_");
                }
                strcat(par.output_file, par.str9);
                strcat(par.output_file, ".txt");
                ofstream enzyme_conc_File(par.output_file);
                enzyme_conc_File << par.time_mean[0] << "\t" << par.EG_conc_mean[0] << "\t" << par.CBH_conc_mean[0] << "\t" << par.BGL_conc_mean[0] << "\t" << par.XYL_conc_mean[0] << endl;
                for(int i=1;i<par.time_mean.size();i++){
                    if(i<par.EG_conc_mean.size())
                        enzyme_conc_File << par.time_mean[i] << "\t" << par.EG_conc_mean[i] << "\t" << par.CBH_conc_mean[i] << "\t" << par.BGL_conc_mean[i] << "\t" << par.XYL_conc_mean[i] << endl;
                }
                enzyme_conc_File.close();

                sprintf(par.str9,"%d",sim_number);
                memset(par.output_file, 0, sizeof(par.output_file));
                strcat(par.output_file, par.outputFileDir.c_str());                    
                strcat(par.output_file, "enzyme_concentration/enzymes_glued_");
                if(argc > 1){
                    strcat(par.output_file, argv[1]);
                    strcat(par.output_file, "_");
                }
                strcat(par.output_file, par.str9);
                strcat(par.output_file, ".txt");
                ofstream lignin_glued_File(par.output_file);
                lignin_glued_File << par.time_mean[0] << "\t" << par.enzymes_glued[0] << endl;
                for(int i=1;i<par.time_mean.size();i++){
                    if(i<par.EG_conc_mean.size())
                      lignin_glued_File << par.time_mean[i] << "\t" << par.enzymes_glued[i] << endl;
                }
                lignin_glued_File.close();



			    memset(par.output_file, 0, sizeof(par.output_file));
			    strcat(par.output_file, par.outputFileDir.c_str());                    
			    strcat(par.output_file, "enzyme_activity/enzyme_activity_");
			    strcat(par.output_file, par.str9);
			    strcat(par.output_file, ".txt");
	            if(par.time_mean.size() > 0){
	    		    ofstream EnzymeFile(par.output_file);
	    	        EnzymeFile << par.time_mean[0] << "\t" << par.EG_activity[0] << "\t" << par.CBH_activity[0] << "\t" << par.BGL_activity[0] << "\t" << par.XYL_activity[0] << "\t" << par.lign_activity[0] << endl;
	    	        for(int i=1;i<par.time_mean.size();i++){
	    	        	EnzymeFile << par.time_mean[i] << "\t" << par.EG_activity[i] << "\t" << par.CBH_activity[i] << "\t" << par.BGL_activity[i] << "\t" << par.XYL_activity[i] << "\t" << par.lign_activity[i] << endl;
	    	        }
	     			EnzymeFile.close();
	            }
	            memset(par.output_file, 0, sizeof(par.output_file));
	            strcat(par.output_file, par.outputFileDir.c_str());                    
	            strcat(par.output_file, "/enzyme_fraction/enzyme_fraction_");
	            if(argc > 1){
	            	strcat(par.output_file, argv[1]);
	            	strcat(par.output_file, "_");
	            }
	            strcat(par.output_file, par.str9);
	            strcat(par.output_file, ".txt");


	            if(par.timestamp.size()>0){
	                ofstream EnzymeFractionFile(par.output_file);
	                EnzymeFractionFile << par.timestamp[0] << "\t" << par.EG_fraction[0] << "\t" << par.CBH_fraction[0] << "\t" << par.BGL_fraction[0] << "\t" << par.XYL_fraction[0] << "\t" << par.lign_fraction[0] << endl;
	                for(int i=1;i<par.timestamp.size();i++){
	                    EnzymeFractionFile << par.timestamp[i] << "\t" << par.EG_fraction[i] << "\t" << par.CBH_fraction[i] << "\t" << par.BGL_fraction[i] << "\t" << par.XYL_fraction[i] << "\t" << par.lign_fraction[i] << endl;
	                }
	                EnzymeFractionFile.close();


		        memset(par.output_file, 0, sizeof(par.output_file));
		        strcat(par.output_file, par.outputFileDir.c_str());                    
		        strcat(par.output_file, "Nbr_reactions/Nbr_reactions_");
		        if(argc > 1){
			        strcat(par.output_file, argv[1]);
			        strcat(par.output_file, "_");
		        }
		        strcat(par.output_file, par.str9);
			    strcat(par.output_file, ".txt");


			    ofstream reaction_number(par.output_file);
			    for(int i=0;i<par.Nbr_reactions.size();i++){
			    	reaction_number << par.time_mean[i] << "\t" << par.Nbr_reactions[i] << endl;
			    }
			    reaction_number.close();

	            }
	            if(heatmap_bool == 1){
	                if(DP_distrib.size()>0){        
	                    memset(par.output_file, 0, sizeof(par.output_file));
	                    strcat(par.output_file, par.outputFileDir.c_str());                    
	                    strcat(par.output_file, "/DP_distrib/DP_distrib_");
                        if(argc > 1){
                            strcat(par.output_file, argv[1]);
                            strcat(par.output_file, "_");
                        }
	                    strcat(par.output_file, par.str9);
	                    strcat(par.output_file, ".txt");             
	                    cout << "Size of DP_distrib: " << DP_distrib.size()*DP_distrib[0].DP.size() << endl;
	                    ofstream DPFile(par.output_file);
	                    for(int i=0; i<DP_distrib.size(); i++){
	                        for(int j=0; j<DP_distrib[i].DP.size();j++){
	                            DPFile << DP_distrib[i].real_time << "\t" << j << "\t" << DP_distrib[i].DP[j] << endl;
	                        }
	                    }
	                    DPFile.close();

	                }
	            }      		
      	}



        //=====================================================================================================================
        //=================================== Clear output data containers for next run========================================
		//=====================================================================================================================

		    par.time_mean.clear();
		    par.amount_glc_mean.clear();
		    par.amount_cellobiose_mean.clear();
		    par.amount_xylose_mean.clear();
            par.EG_conc_mean.clear();
            par.CBH_conc_mean.clear();
            par.BGL_conc_mean.clear();
            par.XYL_conc_mean.clear();
		    par.EG_activity.clear();
		    par.CBH_activity.clear();
		    par.BGL_activity.clear();
		    par.XYL_activity.clear();
            par.lign_activity.clear();
            par.EG_fraction.clear();
            par.CBH_fraction.clear();
            par.BGL_fraction.clear();
            par.XYL_fraction.clear();
            par.lign_fraction.clear();
            par.timestamp.clear();
            par.enzymes_glued.clear();
            par.Nbr_reactions.clear();
            if(heatmap_bool == 1)
                DP_distrib.clear();
		}
	    else{
	    	cout << "No data in mean_file" << endl;
	    }
        cout << "====================================" << endl;        
        sim_number++;
    }



    //===================== Print mean values to file ==================== 


    if(verbose == true){
        if(heatmap_bool == 1)
            cout << "DP_distrib.size() = " << DP_distrib.size() << endl;
        cout << "outputBoundary: " << outputBoundary << endl;
    }



    cout << "Mean glc produced: " << mean << endl;
//    cout << "Mean lignin percentage: " << mean << endl;    



    cout << "END OF main()!!!" << endl;
    return 0;
//===========================================================================================================================================================
//=================================================================== END OF MAIN ===========================================================================
//=========================================================================================================================================================== 
}


//===========================================================================================================================================================
//=================================================== THIS RUNS THE GILLESPIE ALGORITHM FOR A SINGLE SIMULATION =============================================
//===========================================================================================================================================================

double run(bool verbose, bool randomSeed, bool vid, bool heatmap_bool, long int seed48, long int seed, const int sim_number, int& outputBoundary, vector<DPList>& DP_distrib, params& par){

 

		//======================================================================================
		//====== Declaration of variables which will not be contained in the "params" struct====
		//======================================================================================

    int x;//Used to assign x-coordinates of polymers
    int y;//Used to assign y-coordinates of polymers
    int z;//Used to assign z-coordinates of bonds within polymers
    int x_selected, y_selected, z_selected;//Used during gillespie algorithm to determine the position of the bond to be digested
    int nbr_poly_cellu;//Number of cellulose polymers in the system
    int nbr_poly_hemi;//Number of hemicellulose polymers in the system
    int nbr_poly_lign;//Number of lignin polymers in the system
    int nbr_bd_hemi;//Initial number of bonds in hemicellulose
    int nbr_Glc_pdt = 0;//Amount of glucose released from microfibil
    int nbr_xyl_pdt = 0;//Amount of xylose released from the microfibril
    int nbr_cellobiose = 0;//Amount of cellobiose in the system
    int nbr_pict_taken;//Number of snapshots taken of the system during the Gillespie loop
    int nbr_poly_overall;//Overall number of polymers in system

    int counter;//Used for filling the microfibril shell with hemicellulose and lignin
    int x1;//Used for filling the microfibril shell with hemicellulose and lignin
    int x2;//Used for filling the microfibril shell with hemicellulose and lignin
    int nbr_anchoring;//Used for filling the microfibril shell with hemicellulose and lignin
    int countLoops = 0;//Used as a limiter for while loops during hole-cutting in microfibril shell

    int test1;//test variables for checking for the existence of specific reactions in the system
    int test2;
    int test3;
    int test4;

    int bond_selected;//Bond selected at gillespie step
    int action_mu1;//Enzymatic action at gillespie step
    int substrate;//Substrate of reaction at gillespie step
    int poly_selected;//Selected polymer at gillespie step
    int cut_applicate;//z coordinate of selected bond at gillespie step
    int table_selected;//Selected reaction table at gillespie step (this number should always be the same as poly_selected)
    int indic_cut;//Value is 0 if the cut is at the head of the polymer, 1 if the cut is at the tip of thepolymer
    int j = 0;//Used for distributing hemicellulose and lignin
    int THRESHOLD;//Checks whether time > Transient
    int mu1;//Used for selecting reaction in specific reaction table during gillespie step

    int min_x = 0;//These four are used to check the positions of the polymers within the fibril during the initialization phase and adjust their status accordingly
    int max_x = 0;
    int min_y = 0;
    int max_y = 0;
    
    int printFreq = 1e3; //Defines, how often a progress message is printed during gillespie loop
    //int pict_3D_Freq = 1e0; //Defines, how often a 3D structure picture is taken during gillespie loop
    int enzyme_activity_Freq = 1;//Defines, how often all reaction tables are screened for the distribution of reactions among enzyme types


    int glucoseOverall = 0;//Overall glucose in the system, including that which is bound inside the microfibril
    int xyloseOverall = 0;//Overall xylose in the system, including that which is bound inside the microfibril

    int count_glc;//For distribution of xylose and glucose in hemicellulose polymers
    int count_xyl;

    int while_count = 0;//For stopping a while-loop in hemicellulose distribution after a maximum number of times
    int count_EG = 0;//Counts the number of times EG acts during the simulation
    int count_CBH = 0;//Counts the number of times CBH acts during the simulation
    int count_BGL = 0;//Counts the number of times BGL acts during the simulation
	int count_xylanase = 0;//Counts the number of times XYL acts during the simulation
    int count_lignin_glue = 0;//Counts the number of times the lignin glueing effect acts during the simulation


	int nbr_molecs_overall = 0;
    int len_polyLoopStart = 0; //Length of polymer before digest
    int reactionsOverall = 0;//Number of reactions within all reaction tables
    int glcBefore = 0;//Glucose in system (in cellulose + in hemicellulose + released) before a digestion step. This is used in order to check whether glucose is created from nothing or lost
    int glcCelluBefore = 0;//Glucose contained in cellulose before a digestion step. This is used in order to check whether glucose is created from nothing or lost
    int glcHemiBefore = 0;//Glucose contained in hemicellulose before a digestion step. This is used in order to check whether glucose is created from nothing or lost
    int lignolBefore = 0;//Lignin units contained in system. These should only change during the initialization phase, since there is nothing in the mode which degrades lignin
    int DP_index = 0;//Index of DP output vector
    int DP_len_index = 0;//Index whose entry is to be increased by one during DP_distribution check

    int Nbr_glc_in_cellu;//Number of glucose molecules initially in the microfibril
    int Nbr_xyl_in_hemi = 0;//Number of xylose molecules initially in the microfibril (calculated depending on percentages of cellulose,hemicellulose and lignin)
    int Nbr_lignol_in_lign = 0;//Number of monolignol molecules initially in the microfibril (calculated depending on percentages of cellulose,hemicellulose and lignin)

    double propensite;//Used to assign propensity values to the reactions in the gillespie algorithm

    double real_time = 0;//stores the time as calculated by the gillespie algorithm
    double a0;//Sum of propensities of all reactions in system
    double suma;//randomly chosen value between 0 and a0

    double r1;//random numbers
    double r2;

    double tau;//gillespie timestep size
    double test;//Used to choose reaction at the beginning of each gillespie step
    double action_target;
    double time_Transient;
    double t0;//Gillespie step count


    //================================= Values used for estimation of system volume. Not used within Gillespie algorithm =====================
    double d_fibril = 3e-9;//diameter of a microfibril in m(rough value from literature)
    double d_glc = 1e-9;//diameter of a glucose molecule in m (rough value)
    double m_glc = 0.180156/(6.022e23); //2.991e-22 ;//mass of a glucose molecule in kg (from wikipedia; molar mass M = 180.156 g/mol); MASS OF HYDROGEN LOST IN BONDS NEEDS TO BE SUBTRACTED 
    double m_dry = 1e-6;//Dry weight of saccharification experiment sample in kg
    double m_hydrogen = 1.67e-27;//Mass of a proton (here to be set equal to the mass of a hydrogen atom)
    double V_solution = 1e-7; //Volume of saccharification experiment sample in m^3
    double m_fibril;//Mass of the microfibril
    double V_fibril;//Volume of the microfibril
    double V_System;//Volume of the entire system, with the microfibril in solution



    bool error_bool = 0;//This is set to 1 if an error is detected at any point in a sub function. If this happens, the code aborts

    string line;//For reading input files

    vector<float> chem_entities;//This contains the amounts of enzymes EG, CBH and BGL available in the system
    vector<float> x_pos_hemi, y_pos_hemi, x_pos_lign, y_pos_lign;//These contain the positions of POSSIBLE ANCHORING for hemicellulose and lignin
    vector<float> vect_hemi_x, vect_hemi_y, vect_lign_x, vect_lign_y;//These contain the positions on the section where hemicellulose and lignin can anchor

    vector<bList> cellu;//Container for all cellulose polymers
    vector<bList> hemi;//Container for all hemicellulose polymers
    vector<bList> lign;//Container for all lignin polymers

    vector<TList> Table_cellu;//Container for all reaction tables for cellulose
    vector<TList> Table_hemi;//Container for all reaction tables for hemicellulose
    TList Table_lign;//reaction table for lignin. Used for "glueing enzymes" function


    //========================= Variables for tracking the computation time taken for executing funtions or parts of the code ================

    vector<double> time_EG;//Stores the computation time each EG-digestions takes
    vector<double> time_CBH;//Stores the computation time each CBH-digestions takes
    vector<double> time_BGL;//Stores the computation time each BGL-digestions takes
    vector<double> time_XYL;//Stores the computation time each XYL-digestions takes
    vector<double> time_find_reaction;//Stores the computation time it takes to find a reaction during each gillespie step
    vector<double> time_per_gillespie_step;//Stores the computation time each gillespie step takes
    

    int neighbor_key; //Used to distribute entries in the maps
    float neighbor_check_radius = 1.5;//Radius for the sphere investigated around each bond within bond_neighbors_cellu and bond_neeighbors_hemi
    if(par.mode_enzyme_size == 1){
     neighbor_check_radius = par.enzyme_radius;
    }
    unordered_map<int,neighborList> bond_neighbors_cellu;//Stores the neighbors of each cellu bond as well as the occupied volume within a sphere of radius par.enzyme_radius around the respective bond
    unordered_map<int,neighborList> bond_neighbors_hemi;//Stores the neighbors of each hemi bond as well as the occupied volume within a sphere of radius par.enzyme_radius around the respective bond




    if(verbose == true){
        cout << "************************************" << endl;
        cout << "Max size of cellu neighbors: " << bond_neighbors_cellu.max_size() << endl;
        cout << "Max size of hemi neighbors: " << bond_neighbors_hemi.max_size() << endl;
        cout << "************************************" << endl;
    }


 	auto t_start = high_resolution_clock::now();
	auto t_end = high_resolution_clock::now();
 	auto t_start_gillespie = high_resolution_clock::now();
	auto t_end_gillespie = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(t_end - t_start);




    //================ Set RNG seeds ================================
    
    struct timeval time;
    gettimeofday(&time,NULL);

    if(randomSeed == false){
        //srand48(10);
        //srand(44);
        cout << "Seed of random number generator is fixed" << endl;
        srand48(seed48);
        srand(seed);
//        if(verbose == true)
            cout << "48:  " << seed48 << "; regular: " << seed << endl;        
    }
    else{
        cout << "Seed of random number generator is NOT fixed" << endl;
//        if(verbose == true)
            cout << "48:  " << ((time.tv_sec * 100) + (time.tv_usec / 100)) << "; regular: " << ((time.tv_sec * 100) + (time.tv_usec / 100)) << endl;
        srand48((time.tv_sec * 100) + (time.tv_usec / 100));
        srand((time.tv_sec * 100) + (time.tv_usec / 100));
 //       if(verbose == true)
            cout << "48:  " << ((time.tv_sec * 100) + (time.tv_usec / 100)) << "; regular: " << ((time.tv_sec * 100) + (time.tv_usec / 100)) << endl;
    }


    //Activate or deactivate inhibition
    if(par.mode_inhib == 1)
        cout << "Inhibition is activated" << endl;
    else if(par.mode_inhib == -1)
        cout << "Inhibition is NOT activated" << endl;


    //===========================================================================
    //==================== Build polymers and reaction tables ===================
    //===========================================================================

    if((par.mode_code==1) or (par.mode_code==2))
        nbr_poly_cellu=24;


    else if((par.mode_code==3) or (par.mode_code==4))
        nbr_poly_cellu=18;

    else if(par.mode_code == 42)
        nbr_poly_cellu = 48;

    cout << "nbr poly cellu: " << nbr_poly_cellu << endl;
    //====================== Build cellulose ======================

    for(int i=0; i<nbr_poly_cellu; i++)
    {

        cellu.push_back(bList());
        cellu[i].index=i;
        cellu[i].set_z(0);

        Table_cellu.push_back(TList());
        initTList(Table_cellu[Table_cellu.size()-1],i);
        cellu[i].reactionTable = Table_cellu.size() - 1;
    }


    for(int i=0; i<nbr_poly_cellu; i++)
    {
        for(int j=0; j<par.length_fibril; j++)
        {
        	if(par.length_fibril>1){
	        	if(j > 1 and j < par.length_fibril-2){
	        		if(par.init_EG > 0)
			            addbond(cellu[i],j,1,1, false);
			        else
			        	addbond(cellu[i],j,-1,1, false);
	        	}
		        else{
		        	if(par.init_CBH > 0 or par.init_EG > 0)
			            addbond(cellu[i],j,1,1, false);
			        else{
			        	if(par.init_BGL > 0 and par.length_fibril < 8)
				        	addbond(cellu[i],j,1,1,false);
				        else
				        	addbond(cellu[i],j,-1,1,false);
			        }

		        }
        	}
        	else
        		addbond(cellu[i],j,1,1, false);
        }
    }
//==============================================================================================================================================
//========================= Read input files which are related to the positioning of cellulose, hemicellulose and lignin =======================
//==============================================================================================================================================

    par.pct_glc = 1. - par.pct_lign - par.pct_hemi;

    //This file defines the configuration of the fibril withOUT regard to the availability of the bonds (conditioned by the positioning and amounts of lignin and hemicellulose)
    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.structParams.c_str());    
    strcat(par.input_file, par.str6);
    strcat(par.input_file, ".txt");



    //Provide cellu with coordinates
    ifstream file1(par.input_file);
    line.clear();
    if(file1)
    {
        int i =0;
        while(getline(file1,line))
        {
            istringstream in(line);
            in >> cellu[i].x >> cellu[i].y;
            i++;
        }
    }
    else{
        cout << "File " << par.input_file << " does not exist. Exiting." << endl;
        exit(1);
    }



    int count_inner = 0;
    //This file defines the positions on a section where hemicellulose can anchor
    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.hydroParams_inner.c_str());
    strcat(par.input_file, par.str7);//This value is 1 or -1 depending on the mode of hemicellulose preference
    strcat(par.input_file, "_");
    strcat(par.input_file, par.str6);//This value can be 1,2,3,4 depending on the configuratin: 24 or 18 Glc per section and the arrangement rectangle or diamond
    strcat(par.input_file, ".txt");

    ifstream file4(par.input_file);
    line.clear();

    if(file4){
        int i =0;
        while(getline(file4,line))
        {
            x_pos_hemi.push_back(0);
            y_pos_hemi.push_back(0);
            istringstream in(line);
            in >> x_pos_hemi.at(i) >> y_pos_hemi.at(i);
/*            cout << "=======================" << endl;
            for(int j=0;j<x_pos_hemi.size();j++){                
                cout << x_pos_hemi[j] << "\t" << y_pos_hemi[j] << endl;
            }*/
            i++;
        }

    }
    else{
        cout << "File " << par.input_file << " does not exist. Exiting." << endl;
        exit(1);
    }

    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.hydroParams_outer.c_str());
    strcat(par.input_file, par.str7);//This value is 1 or -1 depending on the mode of hemicellulose preference
    strcat(par.input_file, "_");
    strcat(par.input_file, par.str6);//This value can be 1,2,3,4 depending on the configuratin: 24 or 18 Glc per section and the arrangement rectangle or diamond
    strcat(par.input_file, ".txt");

    {ifstream file4(par.input_file);
    line.clear();
    if(file4){
        int i = x_pos_hemi.size()-1;
        if(i < 0){
            i = 0;
        }
        while(getline(file4,line))
        {
            x_pos_hemi.push_back(0);
            y_pos_hemi.push_back(0);
            istringstream in(line);
            in >> x_pos_hemi.at(i) >> y_pos_hemi.at(i);
/*            cout << "=======================" << endl;
            for(int j=0;j<x_pos_hemi.size();j++){                
                cout << x_pos_hemi[j] << "\t" << y_pos_hemi[j] << endl;
            }*/
            i++;
        }

    }
    else{
        cout << "File " << par.input_file << " does not exist. Exiting." << endl;
        exit(1);
    }}

    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.hydroParams_inner.c_str());
    strcat(par.input_file, par.str8);//This value is 1 or -1 depending on the mode of lignin preference
    strcat(par.input_file, "_");
    strcat(par.input_file, par.str6);//This value can be 1,2,3,4 depending on the configuratin: 24 or 18 Glc per section and the arrangement rectangle or diamond
    strcat(par.input_file, ".txt");

    {ifstream file5(par.input_file);
    line.clear();
    if(file5)
    {
        int i =0;
        while(getline(file5,line))
        {
            x_pos_lign.push_back(0);
            y_pos_lign.push_back(0);
            istringstream in(line);
            in >> x_pos_lign.at(i) >> y_pos_lign.at(i);
            i++;
        }
    }
    else{
        cout << "File " << par.input_file << " does not exist. Exiting." << endl;
        exit(1);
    }}

    memset(par.input_file, 0, sizeof(par.input_file));
    strcat(par.input_file, par.paramFileDir.c_str());
    strcat(par.input_file, par.hydroParams_outer.c_str());
    strcat(par.input_file, par.str8);//This value is 1 or -1 depending on the mode of lignin preference
    strcat(par.input_file, "_");
    strcat(par.input_file, par.str6);//This value can be 1,2,3,4 depending on the configuratin: 24 or 18 Glc per section and the arrangement rectangle or diamond
    strcat(par.input_file, ".txt");
//                ifstream file5(par.input_file);
    line.clear();
    ifstream file5(par.input_file);

    if(file5){
        int i = x_pos_lign.size() - 1;
        if(i < 0){
            i = 0;
        }
        while(getline(file5,line))
        {
            x_pos_lign.push_back(0);
            y_pos_lign.push_back(0);
            istringstream in(line);
            in >> x_pos_lign.at(i) >> y_pos_lign.at(i);
            i++;
        }
    }
    else{
        cout << "File " << par.input_file << " does not exist. Exiting." << endl;
        exit(1);
    }

    vector<float> x_pos_shell_save;
    vector<float> y_pos_shell_save;

    for(int i=0;i<x_pos_hemi.size();i++){
    	x_pos_shell_save.push_back(x_pos_hemi[i]);
    	y_pos_shell_save.push_back(y_pos_hemi[i]);
    }

    if(par.mode_hemi == par.mode_lign){
        int max_outer_layer_polys = x_pos_hemi.size();
        int N_polys = int(float(nbr_poly_cellu)/par.pct_glc);
        if(N_polys > x_pos_hemi.size()+nbr_poly_cellu){
//            cout << "Configuration not possible with the specified polymer coordinate files; max_outer_layer_polys = " << max_outer_layer_polys << "; N_hemi_lign_polys = " << N_hemi_lign_polys << endl;
            cout << "Please change the percentages of hemicellulose and lignin; minimal cellulose percentage is " << float(nbr_poly_cellu)/float(nbr_poly_cellu + x_pos_hemi.size()) << endl;
            exit(1);
        }

        cout << "N_polys = " << N_polys << endl;
        if(N_polys < float(nbr_poly_cellu)/par.pct_glc){
            N_polys++;
        }
        int N_hemi_lign_polys = N_polys - nbr_poly_cellu;

        if(N_hemi_lign_polys > x_pos_hemi.size()){
            cout << "Configuration not possible with the specified polymer coordinate files; max_outer_layer_polys = " << max_outer_layer_polys << "; N_hemi_lign_polys = " << N_hemi_lign_polys << endl;
            exit(1);
        }

        while(float(N_hemi_lign_polys)/float(N_hemi_lign_polys+nbr_poly_cellu) < par.pct_hemi+par.pct_lign){
            N_hemi_lign_polys++;
        }
        if(x_pos_hemi.size() > N_hemi_lign_polys){
            x_pos_hemi.erase(x_pos_hemi.begin()+N_hemi_lign_polys, x_pos_hemi.begin()+x_pos_hemi.size());
            y_pos_hemi.erase(y_pos_hemi.begin()+N_hemi_lign_polys, y_pos_hemi.begin()+y_pos_hemi.size());
            if(x_pos_lign.size() > 0){
                x_pos_lign.erase(x_pos_lign.begin()+N_hemi_lign_polys, x_pos_lign.begin()+x_pos_lign.size());
                y_pos_lign.erase(y_pos_lign.begin()+N_hemi_lign_polys, y_pos_lign.begin()+y_pos_lign.size());            
            }
        }





        unordered_map<int,vector<int>> blocked_positions;
        int key_to_add = 0;
        vector<int> array_to_add;
        array_to_add.push_back(0);
        array_to_add.push_back(0);
        vector<int> keys_of_blocked_positions;
        int offset = 0;//Offset to enable use of the cantor_pairing function (some of the coordinates in the hydro param file may be negative)


        for(int i=0;i<x_pos_hemi.size();i++){
            key_to_add = cantor_pair_two(x_pos_hemi[i] + offset,y_pos_hemi[i] + offset);
            if(verbose == true){
                cout << "xcoord = " << x_pos_hemi[i] + offset << ";ycoord = " << y_pos_hemi[i] + offset << endl;
                cout << "new key = " << key_to_add << endl;                
            }
            if(blocked_positions.count(key_to_add) == 0){
                keys_of_blocked_positions.push_back(key_to_add);
                array_to_add[0] = x_pos_hemi[i];
                array_to_add[1] = y_pos_hemi[i];
                blocked_positions.insert(make_pair(key_to_add,array_to_add));
            }
        }

        int N_hemi_polys = int(par.pct_hemi*float(N_polys))+1;
        int N_lign_polys = int(par.pct_lign*float(N_polys))+1;
        if(par.pct_hemi == 0 and par.pct_lign == 0){
            N_hemi_polys = 0;
            N_lign_polys = 0;
        }
        else if(par.pct_hemi == 0){
            N_lign_polys = N_hemi_lign_polys;
            N_hemi_polys = 0;
        }
        else if(par.pct_lign == 0){
            N_hemi_polys = N_hemi_lign_polys;
            N_lign_polys = 0;
        }


        if(verbose == true){
            cout << "N_hemi_polys = " << N_hemi_polys << "; N_lign_polys = " << N_lign_polys << "; N_hemi_lign_polys = " << N_hemi_lign_polys << endl;
        }

        int picking_index = 0;
        int count_hemi = 0;
        int count_lign = 0;
        while(count_hemi < N_hemi_polys){
            picking_index = int(drand48()*(keys_of_blocked_positions.size()-1));
            vect_hemi_x.push_back(blocked_positions[keys_of_blocked_positions[picking_index]][0]);
            vect_hemi_y.push_back(blocked_positions[keys_of_blocked_positions[picking_index]][1]);
            keys_of_blocked_positions.erase(keys_of_blocked_positions.begin() + picking_index);
            count_hemi++;
        }
        for(int i=0;i<keys_of_blocked_positions.size();i++){
            vect_lign_x.push_back(blocked_positions[keys_of_blocked_positions[i]][0]);
            vect_lign_y.push_back(blocked_positions[keys_of_blocked_positions[i]][1]);
        }
        blocked_positions.clear();
        keys_of_blocked_positions.clear();

		N_hemi_polys = int(par.pct_hemi*float(N_polys))+1;
 		N_lign_polys = int(par.pct_lign*float(N_polys))+1;

	    Nbr_glc_in_cellu = (par.length_fibril+1) * nbr_poly_cellu;

	    nbr_molecs_overall = int(double(Nbr_glc_in_cellu)/(1. - par.pct_lign - par.pct_hemi));

	    Nbr_xyl_in_hemi = int(nbr_molecs_overall * par.pct_hemi);
	    Nbr_lignol_in_lign = int(nbr_molecs_overall * par.pct_lign);

	    if(vect_hemi_x.size() + vect_lign_x.size() > N_polys - nbr_poly_cellu){
	    	cout << "Problem: more new polys specified than there is room for in outer layer. Stopping" << endl;
	    	exit(1);
	    }

	    while(vect_hemi_x.size() * (par.length_fibril+1) < Nbr_xyl_in_hemi){
	    	int test5 = 0;
	    	for(int i=0; i<x_pos_shell_save.size(); i++){
	    		test5 = 0;
	    		for(int j=0; j<vect_hemi_x.size(); j++){
	    			if(x_pos_shell_save[i] == vect_hemi_x[i] and y_pos_shell_save[i] == vect_hemi_y[i]){
	    				test5 = 1;
	    			}
	    		}
	    		for(int j=0; j<vect_lign_x.size(); j++){
	    			if(x_pos_shell_save[i] == vect_lign_x[i] and y_pos_shell_save[i] == vect_lign_y[i]){
	    				test5 = 1;
	    			}	    			
	    		}
	    		if(test5 == 0){
	    			vect_hemi_x.push_back(x_pos_shell_save[i]);
	    			vect_hemi_y.push_back(y_pos_shell_save[i]);
	    		}
	    		if(vect_hemi_x.size() * (par.length_fibril+1) >= Nbr_xyl_in_hemi){
	    			break;
	    		}
	    	}

	    }
	    while(vect_lign_x.size() * (par.length_fibril+1) < Nbr_lignol_in_lign){
	    	int test5 = 0;
	    	for(int i=0; i<x_pos_shell_save.size(); i++){
	    		test5 = 0;
	    		for(int j=0; j<vect_hemi_x.size(); j++){
	    			if(x_pos_shell_save[i] == vect_hemi_x[i] and y_pos_shell_save[i] == vect_hemi_y[i]){
	    				test5 = 1;
	    			}
	    		}
	    		for(int j=0; j<vect_lign_x.size(); j++){
	    			if(x_pos_shell_save[i] == vect_lign_x[i] and y_pos_shell_save[i] == vect_lign_y[i]){
	    				test5 = 1;
	    			}	    			
	    		}
	    		if(test5 == 0){
	    			vect_lign_x.push_back(x_pos_shell_save[i]);
	    			vect_lign_y.push_back(y_pos_shell_save[i]);
	    		}
	    		if(vect_lign_x.size() * (par.length_fibril+1) >= Nbr_lignol_in_lign){
	    			break;
	    		}
	    	}
	    }
	    int difference_hemi = vect_hemi_x.size() * (par.length_fibril + 1) - Nbr_xyl_in_hemi;
	    int difference_lign  = vect_lign_x.size() * (par.length_fibril + 1) - Nbr_lignol_in_lign;
	    cout << " After building vect_x_hemi usw: difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign << endl;

    }
    else{
        int max_outer_layer_polys = x_pos_hemi.size();

        int N_polys = int(float(nbr_poly_cellu)/par.pct_glc);

        int N_hemi_polys = par.pct_hemi*float(N_polys);
        int N_lign_polys = par.pct_lign*float(N_polys);

        while(float(N_hemi_polys)/float(N_polys) < par.pct_hemi){
            N_hemi_polys++;
        }
        while(float(N_lign_polys)/float(N_polys) < par.pct_lign){
            N_lign_polys++;
        }
        if(N_hemi_polys + N_lign_polys > max_outer_layer_polys){
            cout << "More polymers to be added than positions available. Stopping" << endl;
            exit(1);
        }

        if(x_pos_hemi.size()>N_hemi_polys){
            x_pos_hemi.erase(x_pos_hemi.begin()+N_hemi_polys, x_pos_hemi.begin()+x_pos_hemi.size());
            y_pos_hemi.erase(y_pos_hemi.begin()+N_hemi_polys, y_pos_hemi.begin()+y_pos_hemi.size());            
        }

        if(x_pos_lign.size()>N_lign_polys){
            x_pos_lign.erase(x_pos_lign.begin()+N_lign_polys, x_pos_lign.begin()+x_pos_lign.size());
            y_pos_lign.erase(y_pos_lign.begin()+N_lign_polys, y_pos_lign.begin()+y_pos_lign.size());            
        }


        for(int i=0; i<x_pos_hemi.size();i++){
            vect_hemi_x.push_back(x_pos_hemi[i]);
            vect_hemi_y.push_back(y_pos_hemi[i]);
        }
        for(int i=0; i<x_pos_lign.size();i++){
            vect_lign_x.push_back(x_pos_lign[i]);
            vect_lign_y.push_back(y_pos_lign[i]);
        }
    }






    cout << "Number of hemi polymers to be added: " << vect_hemi_x.size() << "; lignin: " << vect_lign_x.size() << endl;
    cout << "Number of hemi polymers to be added: " << vect_hemi_y.size() << "; lignin: " << vect_lign_y.size() << endl;










    //==========================================================================================================================
    //========================== Initiation of lignin and hemicellulose structures and acetylation =============================
    //==========================================================================================================================

    //Initiate elements for hemicellulose


    cout << "Building hemi and lignin polymers" << endl;



    int new_poly_length = 0;
    int gap_start = 0;



    nbr_poly_hemi = 0;
    for(int i=0; i<vect_hemi_x.size(); i++)
    {

        hemi.push_back(bList());
        nbr_poly_hemi++;
        hemi[i].x=vect_hemi_x.at(i);
        hemi[i].y=vect_hemi_y.at(i);
        hemi[i].set_z(0);

        Table_hemi.push_back(TList());
        initTList(Table_hemi[Table_hemi.size()-1],i);        
        //cout << Table_hemi.size() << endl;
        hemi[i].reactionTable = Table_hemi.size() - 1;

        for(int j=0; j<par.length_fibril; j++){
    		if(par.init_XYL > 0)
	            addbond(hemi[i],j,1,4, false);
	        else
	        	addbond(hemi[i],j,-1,4, false);
        }
    }

    //Distribute bond types in hemicellulose: 1 for glc-glc, 2 for xyl-glc, 3 for glc-xyl, 4 for xyl-xyl, and -1 for lign-lign. For now this is only important for hemicellulose
    count_glc = 0;
    while_count = 0;
    long int max_while = 10 * par.length_fibril;
    if(par.pct_xyl == 1){
    	for(int i=0;i<hemi.size();i++){
    		for(int j=0;j<hemi[i].bond_type.size();j++)
    			hemi[i].bond_type[j] = 4;
		}
    }
    else if(par.pct_xyl > 0){
    	for(int i=0;i<hemi.size();i++){
    		while_count = 0;
    		count_glc = 0;
    		while(double(count_glc)/double(par.length_fibril) < 1. - par.pct_xyl){
    			if(while_count >= max_while)
    				break;
				hemi[i].bond_type[int(drand48()*par.length_fibril)] = 1;
				if(hemi[i].bond_type[j-1] == 0 and hemi[i].bond_type[j+1] == 0){
					count_glc+=2;
				}
				else if(hemi[i].bond_type[j-1] == 1 and hemi[i].bond_type[j+1] == 1){
					//do nothing
				}
				else{
					count_glc++;
				}
    			while_count++;
    		}

    		if(par.length_fibril > 1){
				for(int j=0;j<hemi[i].len_poly;j++){
		    		if(hemi[i].bond_type[j] != 1){
		    			if(j == 0){
		    				if(hemi[i].bond_type[j+1] == 1){
		    					hemi[i].bond_type[j] = 2;
		    				}
		    				else{
		    					hemi[i].bond_type[j] = 4;
		    				}
		    			}
		    			else if(j == hemi[i].len_poly-1){
		    				if(hemi[i].bond_type[j-1] == 1){
		    					hemi[i].bond_type[j] = 3;
		    				}
		    				else{
		    					hemi[i].bond_type[j] = 4;
		    				}
		    			}
		    			else{
								hemi[i].bond_type[j] = find_bond_type(hemi[i].bond_type[j-1],hemi[i].bond_type[j+1]);
								if(hemi[i].bond_type[j] == 42){
									exit(1);
								}
	    				}

	    			}
	    		}
    		}
    		else if(par.length_fibril > 0){
    			if(hemi[i].bond_type[0] == 0)
    				hemi[i].bond_type[0] = 4;
    		}    		
		}
	}
	count_xyl = 0;
	count_glc = 0;
	for(int k=0;k<hemi.size();k++){

		if(hemi[k].bond_type[0] == 1 or hemi[k].bond_type[0] == 3)
			count_glc++;
		else if(hemi[k].bond_type[0] == 0){
			cout << "A bond_type in hemi is 0! This must have happened during initialization." << endl;
			exit(1);
		}
		else
			count_xyl++;

		for(int i=1;i<hemi[k].bond_type.size();i++){
		
		if(hemi[k].bond_type[i-1] == 1 or hemi[k].bond_type[i-1] == 2)
			count_glc++;
		else if(hemi[k].bond_type[i] == 0){
			cout << "A bond_type in hemi is 0! This must have happened during initialization." << endl;
			exit(1);
		}		
		else
			count_xyl++;
		}
	}
	cout << "Xylose percentage in hemicellulose: " << double(count_xyl)/double(par.length_fibril * hemi.size()) << "; Glucose percentage in hemicellulose: " <<  double(count_glc)/double(par.length_fibril*hemi.size()) << endl;


    cout << "\n" << endl;




//    nbr_poly_hemi=vect_hemi_x.size();
    nbr_bd_hemi=nbr_poly_hemi*par.length_fibril;

    //Acetylation of hemicellulose
    counter=0;
    if(par.pct_acetyl_hemi > 0){
	    while(counter<nbr_bd_hemi*par.pct_acetyl_hemi)
	    {

	        x1 = rand()%(int)(nbr_poly_hemi);//x1 ranges from 0 to Tot_hemi-1
	        x2 = rand()%(int)(par.length_fibril);

	        if(hemi[x1].status[x2]==1)//If this position is not acetylated
	        {
	            hemi[x1].status[x2]=-2;
	            counter++;
	        }
	    }
    }

    //Initiate elements for lignin
    for(int i=0; i<vect_lign_x.size(); i++)
    {
        lign.push_back(bList());
        nbr_poly_lign++;
        lign[i].x=vect_lign_x.at(i);
        lign[i].y=vect_lign_y.at(i);
        lign[i].set_z(0);

        for(int j=0; j<par.length_fibril; j++)
            addbond(lign[i],j,-2,-1, false);
    }

    nbr_poly_lign=vect_lign_x.size();
    nbr_poly_overall = nbr_poly_cellu + nbr_poly_hemi + nbr_poly_lign;



    cout << "Number of hemi polys: " << nbr_poly_hemi << "; number of lignin polys: " << nbr_poly_lign << endl;
    min_max_cellu_hemi_lign(cellu,hemi,lign,par);//Set coordinates of boundaries for hemi and lign
    cout << "Number of hemi polys: " << nbr_poly_hemi << "; number of lignin polys: " << nbr_poly_lign << endl;
    cout << "\n" << endl;
    cout << "\n" << endl;    
    //======================================================================================
    //========================= Adjust hemicellulose and lignin ============================
    //======================================================================================

    if(par.mode_hemi == par.mode_lign)//If they have same side preference
        nbr_anchoring=x_pos_hemi.size();//They will compete for anchoring site
    if(par.mode_hemi != par.mode_lign)//If they have different
        nbr_anchoring=x_pos_hemi.size()+x_pos_lign.size();


    if(verbose == true){
        cout << "nbr_anchoring = " << nbr_anchoring << endl;
    }





    Nbr_glc_in_cellu = (par.length_fibril+1) * nbr_poly_cellu;

    nbr_molecs_overall = int(double(Nbr_glc_in_cellu)/(1. - par.pct_lign - par.pct_hemi));

    Nbr_xyl_in_hemi = int(nbr_molecs_overall * par.pct_hemi);
    Nbr_lignol_in_lign = int(nbr_molecs_overall * par.pct_lign);

    nbr_poly_hemi = hemi.size();
    nbr_poly_lign = lign.size();



    int difference_hemi = nbr_poly_hemi * (par.length_fibril + 1) - Nbr_xyl_in_hemi;
    int difference_lign  = nbr_poly_lign * (par.length_fibril + 1) - Nbr_lignol_in_lign;
    if(verbose == true){
        cout << "difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign << "\n" << endl;
    }

    cout << "*****************" << endl;
    cout << "Adjusting hemi and lign..." << endl;
    cout << "*****************" << endl;    

    cout << "\n" << endl;
    cout << "\n" << endl;    

    x_pos_shell_save.clear();
    y_pos_shell_save.clear();


    if(nbr_poly_hemi > 0){

        if(difference_hemi < 0){
            cout << "Configuration not possible: difference_hemi < 0; difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign << "; nbr_poly_hemi = " << nbr_poly_hemi << "; nbr_poly_lign = " << nbr_poly_lign << endl;
            exit(1);
        }
        if(difference_lign < 0){
            cout << "Configuration not possible: difference_lign < 0; difference_hemi = " << difference_hemi << "; difference_lign = " << difference_lign  << "; nbr_poly_hemi = " << nbr_poly_hemi << "; nbr_poly_lign = " << nbr_poly_lign << endl;
            exit(1);
        }
        if(difference_hemi > 0 or difference_lign > 0){
            hole_cutter(cellu, hemi, lign, Table_hemi, par, difference_hemi, difference_lign, nbr_poly_hemi, nbr_poly_lign, error_bool, 2);
            if(error_bool == 1){
                cout << "Error in function hole_cutter(); aborting" << endl;
                exit(1);;
            }

        }
        else if(difference_hemi == 0){
            cout << "difference_hemi = 0" << endl;
        }
    }
    cout << "Done adjusting hemi and lign" << endl;


    Nbr_xyl_in_hemi = 0;
    Nbr_lignol_in_lign = 0;
    for(int i=0; i<nbr_poly_hemi;i++){
        Nbr_xyl_in_hemi += (hemi[i].len_poly + 1);
    }
    for(int i=0; i<nbr_poly_lign; i++){
        Nbr_lignol_in_lign += (lign[i].len_poly + 1);
    }
    par.nbr_monolignol = Nbr_lignol_in_lign;

// ===========================================================================================================
// =============================== Build maps of neighboring bonds =========================================
// ===========================================================================================================


//    char neighbor_key[3];//Stores the three coordinates used to find the neighbor entry within the neighbor maps 
    cout << "\n" << endl;
    cout << "\n" << endl;    
    cout << "Filling neighbor vectors" << endl;
    if(verbose==true){

        cout << "enzyme radius = " << par.enzyme_radius << "; monomer radius = " << par.r_monomer << endl;


        cout << "Sizes before: cellu_neighbors: " << bond_neighbors_cellu.size() << "; hemi: " << bond_neighbors_hemi.size() << endl;
    }
    for(int i=0;i<nbr_poly_cellu;i++){
  //          neighbor_key[0] = char(cellu[i].x);
  //          neighbor_key[2] = char(cellu[i].y);
        for(int j=0;j<cellu[i].len_poly;j++){
            neighbor_key = cantor_pair_three(cellu[i].x,cellu[i].y, cellu[i].z[j]);
//            neighbor_key[3] = char(cellu[i].z[j]);
//           cout << "Inserting, i= " << i << "; j = " << j << endl;
            if(bond_neighbors_cellu.count(neighbor_key) == 0){
                bond_neighbors_cellu.insert({neighbor_key, neighborList(cellu[i].x, cellu[i].y, cellu[i].z[j], neighbor_check_radius, par, cellu, hemi, lign)});
            }
//            if(verbose == true){

//                cout << bond
//            }
//            bond_neighbors_cellu.push_back(neighborList(cellu[i].x, cellu[i].y, cellu[i].z[j], par.V_enzyme, par, cellu, hemi, lign));
//            cout << "Done inserting" << endl;
        }
    }
    for(int i=0;i<nbr_poly_hemi;i++){

//            neighbor_key[0] = char(hemi[i].x);
//            neighbor_key[2] = char(hemi[i].y);
        for(int j=0;j<hemi[i].len_poly;j++){
            neighbor_key = cantor_pair_three(hemi[i].x,hemi[i].y, hemi[i].z[j]);
//            neighbor_key[3] = char(hemi[i].z[j]);
            if(bond_neighbors_hemi.count(neighbor_key) == 0){
                bond_neighbors_hemi.insert({neighbor_key, neighborList(hemi[i].x, hemi[i].y, hemi[i].z[j], neighbor_check_radius, par, cellu, hemi, lign)});
            }
        }
    }
    cout << "\n" << endl;
    cout << "\n" << endl;    
    cout << "Done filling neighbor vectors" << endl;
    cout << "\n" << endl;
    cout << "\n" << endl;    


    if(verbose == true){
        cout << "************************************" << endl;
        cout << "Size of cellu neighbors: " << bond_neighbors_cellu.size() << endl;
        cout << "Size of hemi neighbors: " << bond_neighbors_hemi.size() << endl;
        cout << "************************************" << endl;

        if(nbr_poly_cellu > 0){
            neighbor_key = cantor_pair_three(cellu[0].x,cellu[0].y, cellu[0].z[0]);
            cout << "Neighbors of first cellu bond: " << bond_neighbors_cellu[neighbor_key].N_neighbors << endl;
        }

    }

/*
    ofstream neighbor_number("Output/slice_of_neighbors.txt");

    int z_slice = 20;
    for(int i=0;i<nbr_poly_cellu;i++){
        neighbor_key = cantor_pair_three(cellu[i].x, cellu[i].y, z_slice);
        if(bond_neighbors_cellu.find(neighbor_key) != bond_neighbors_cellu.end()){
            neighbor_number << cellu[i].x << "\t" << cellu[i].y << "\t" << bond_neighbors_cellu[neighbor_key].N_neighbors << endl;
        }
    }

    neighbor_number.close();*/


//    return 0;
    //====================== Set statuses of cellu and hemi bonds ==================================================


    // ====================  Accessibility of Xyl bonds based on anchoring of lignin and hemicellulose =============================


    if(nbr_poly_hemi > 0){

        for(int i = 0;i<nbr_poly_hemi;i++){

        	if(hemi[i].len_poly>0){
                hemi[i].status[0] = 1;
                hemi[i].status[hemi[i].len_poly-1] = 1;
                for(int j=1;j<hemi[i].len_poly-1;j++){
                    if(verbose == true){
//                        if(is_outer_poly(bond_neighbors_cellu, bond_neighbors_hemi, hemi, lign, cellu, hemi[i].x, hemi[i].y, hemi[i].z[j], 2, par) == false and hemi[i].x == -2 and hemi[i].y == 10){
//                            cout << "An outer polymer was falsely specified by function is_outer_poly() as an inner polymer. Stopping." << endl;
//                            cout << "Polymer coordinates: (" << hemi[i].x << ", " << hemi[i].y << ")" << endl;
//                            exit(1);
//                        cout << "."<<endl;
                    }
                    if(bond_neighbors_hemi[cantor_pair_three(hemi[i].x, hemi[i].y, hemi[i].z[j])].outer_bond == true){
	                    hemi[i].status[j] = 1;                        
                    }
		            else{
		                hemi[i].status[j] = -1;
		            }
//		            if(is_outer_poly(bond_neighbors_cellu, bond_neighbors_hemi, hemi, lign, cellu, hemi[i].x, hemi[i].y, hemi[i].z[j], 2, par) == true){
	            //if(hemi[i].x == min_x or hemi[i].x == max_x or hemi[i].y == min_y or hemi[i].y == max_y){
	            }


        	}
        }
    }


    //=========================== Accessibility of Glc bonds based on their position in the bulk of the fibril and anchoring of hemi and lign =========================



    for(int i=0;i<nbr_poly_cellu;i++){
        if(par.length_fibril>1){
            cellu[i].status[0] = 1;//The tip of the polymer is still attackable by CBH
            cellu[i].status[1] = 1;//But CBH attacks the second bond from the top/bottom
            cellu[i].status[par.length_fibril -1] = 1;
            cellu[i].status[par.length_fibril -2] = 1;
            if(cellu[i].x == par.min_x_cellu or cellu[i].x == par.max_x_cellu or cellu[i].y == par.min_y_cellu or cellu[i].y == par.max_y_cellu){
                for(int j=2; j<par.length_fibril-2; j++){
                    if(verbose == true){
                        /*
                        if(is_outer_poly(bond_neighbors_cellu, bond_neighbors_hemi, hemi, lign, cellu, cellu[i].x, cellu[i].y, cellu[i].z[j], 2, par) == true){
                            cout << "An outer polymer was falsely specified by function is_outer_poly() as an inner polymer. Stopping." << endl;
                            cout << "Polymer coordinates: (" << cellu[i].x << ", " << cellu[i].y << ")" << endl;
                            exit(1);
                        }
                        */
                    }
/*                	if(is_outer_poly(bond_neighbors_cellu, bond_neighbors_hemi, hemi,lign,cellu, cellu[i].x, cellu[i].y, cellu[i].z[j], 1, par) == true){
                		cellu[i].status[j] = 1;
                	}*/
                    if(bond_neighbors_cellu[cantor_pair_three(cellu[i].x, cellu[i].y, cellu[i].z[j])].outer_bond == true){
                        cellu[i].status[j] = 1;
                    }
                	else{
	                    cellu[i].status[j]=-1;
                	}
                }
            }
            else{
                for(int j=2; j<par.length_fibril-2; j++){
                    cellu[i].status[j]=-1;
                }
            }
        }
        else if(par.length_fibril == 1){
            cellu[i].status[0] = 1;
        }        
        else{
            cout << "fibril length is 0. Stopping." << endl;
            exit(1);
        }
    }



    // ========================  Set crystallinity ===================================

    int count_crystalline = 0;
    int count_cellu = countGlc(cellu,1);
	if(par.pct_crystalline_cellu > 0 and par.pct_crystalline_cellu <= 1){
	    int z_crystal_lower = int((par.length_fibril-1) * 0.5 * (1. - par.pct_crystalline_cellu));
	    int z_crystal_upper = par.length_fibril - 1 - z_crystal_lower;

	    cout << "Cellulose is crystalline between z = " << z_crystal_lower << " and z = " << z_crystal_upper << endl;

	    for(int i=0;i<nbr_poly_cellu;i++){
	    	for(int j=0;j<cellu[i].len_poly;j++){
	    		if(cellu[i].z[j] >= z_crystal_lower and cellu[i].z[j] < z_crystal_upper){
	    			cellu[i].crystalline[j] = true;
                    count_crystalline++;
	    		}
	    	}
	    }
        cout << "this amounts to a percentage of " << double(count_crystalline)/double(count_cellu) << endl;
	}
    count_crystalline = 0;
	int count_hemi = countXyl(hemi);
    int poly_to_crystalize = 0;
    int bond_to_crystalize = 0;
	if(par.pct_crystalline_hemi > 0 and par.pct_crystalline_hemi <= 1){
//	    z_crystal_lower = int((par.length_fibril-1) * 0.5 * (1. - par.pct_crystalline_hemi));
//	    z_crystal_upper = par.length_fibril - 1 - z_crystal_lower;
/*
        while(double(count_crystalline)/double(count_hemi) < par.pct_crystalline_hemi){
            poly_to_crystalize = int(drand48() * (nbr_poly_hemi-1));
            if(poly_to_crystalize >= 0){
                if(hemi[poly_to_crystalize].len_poly > 0){
//                    cout << "Found poly" << endl;
                    bond_to_crystalize = int(drand48() * double(hemi[poly_to_crystalize].len_poly-1));
                    if(bond_to_crystalize >= 0){
//                        cout << "Found bond: " << bond_to_crystalize << "; len_poly: " << hemi[poly_to_crystalize].len_poly << endl;
                        if (hemi[poly_to_crystalize].crystalline[bond_to_crystalize] == false){
                            hemi[poly_to_crystalize].crystalline[bond_to_crystalize] = true;
                            count_crystalline++;
                        }
                    }
                }
            }
        }
*/
        while(double(count_crystalline)/double(count_hemi) < par.pct_crystalline_hemi){
    	    for(int i=0;i<nbr_poly_hemi;i++){
    	    	for(int j=0;j<hemi[i].len_poly;j++){

    	    		if(drand48() < par.pct_crystalline_hemi and double(count_crystalline)/double(count_hemi) < par.pct_crystalline_hemi){
    	    			hemi[i].crystalline[j] = true;
    	    			count_crystalline++;
    	    		}
    //    			count_hemi++;
    	    	}
    	    }            
        }

	    cout << "Hemi crystalline percentage = " << double(count_crystalline)/double(count_hemi) << " or " << par.pct_crystalline_hemi << endl;
	}




    // ========================  Initial configuration of chemical entities ===================================


    //Chemical entities vector

    for(int i=0; i<5; i++)
        chem_entities.push_back(0.0);

    chem_entities.at(0)=par.init_EG;
    chem_entities.at(1)=par.init_CBH;
    chem_entities.at(2)=par.init_BGL;
    chem_entities.at(3)=par.init_XYL;
    chem_entities.at(4)=par.nbr_monolignol;// + par.init_EG + par.init_CBH + par.init_BGL + par.init_XYL;

    cout << "number of enzymes which can be blocked by lignin: " << int(par.nbr_monolignol / (2.*float(par.enzyme_radius) + 3.)) << endl;

    par.nbr_lignin_blocked = 0;//No enzymes are bound to lignin yet






    // ================================================================================================
    // ============================  Fill propensity tables ===========================================
    // ================================================================================================

    //======================================= Digestion by EG (and XYL for hemicellulose!)

//    propensite=prop(1,chem_entities);//For now cellulose and hemicellulose are digested with same rates
    for(int i=0;i<Table_cellu.size();i++){
    //    initTList(Table_cellu[i],i);
        fill_table(par,Table_cellu, cellu, i, 1, error_bool,chem_entities);
        for(int j=0;j<Table_cellu[i].nbr_element;j++){
            if(Table_cellu[i].num_bond[j] == 0 or Table_cellu[i].num_bond[j] == 1 or Table_cellu[i].num_bond[j] == cellu[i].len_poly-1 or Table_cellu[i].num_bond[j] == cellu[i].len_poly-2){
                if(Table_cellu[i].indic_action[j] == 1){
                    cout << "Fcuntion fill_table adds EG reactions at start or end! stopping" << endl; 
                    exit(1);
                }
            }
        }
    }
    if(error_bool == 1){
        cout << "Error in filling up Table_cellu. stopping" << endl;
        exit(1);
    }
    
    for(int i=0;i<Table_hemi.size();i++){
     //   initTList(Table_hemi[i],i);
        fill_table(par,Table_hemi, hemi, i, 2,error_bool,chem_entities); 
        for(int j=0;j<Table_hemi[i].nbr_element;j++){
            if(Table_hemi[i].num_bond[j] >= hemi[i].len_poly){
                cout << "Function fill_table() produces reactions in Table_hemi which point to bonds outside of the polymer length. Stopping" << endl;
                exit(1);
            }
        }
    }

    if(error_bool == 1){
    cout << "Error in filling up Table_cellu. stopping" << endl;
    exit(1);
    }



    a0=0.;

    for(int i=0; i<nbr_poly_cellu; i++){//sum up propensities for cellu
        Table_cellu[i].calcTableProp();
        a0 += Table_cellu[i].prop_sum;

    }

    for(int i=0; i<nbr_poly_hemi; i++){//sum up propensities for hemi
        Table_hemi[i].calcTableProp();
        if(verbose == true)
        	cout << "Table_hemi[" << i << "].nbr_element = " << Table_hemi[i].nbr_element << "; prop_sum = " << Table_hemi[i].prop_sum << endl;
        a0 += Table_hemi[i].prop_sum;
    }



    	//=================== Check if tables were filled correctly =======================

    for(int i=0;i<Table_cellu.size();i++){
        for(int j=0;j<Table_cellu[i].nbr_element;j++){
            if(Table_cellu[i].indic_action[j] == 2 and (Table_cellu[i].num_bond[j] == 0 or Table_cellu[i].num_bond[j] == par.length_fibril - 1)){
                cout << "Initialization of CBH reactions not correct: a reaction was found at bond " << Table_cellu[i].num_bond[j] << "; stopping..." << endl;
                exit(1);
            }
            if(Table_cellu[i].indic_action[j] == 1 and (Table_cellu[i].num_bond[j] == 0 or Table_cellu[i].num_bond[j] == par.length_fibril - 1)){
                cout << "Initialization of EG reactions not correct: a reaction was found at bond " << Table_cellu[i].num_bond[j] << "; stopping..." << endl;
                exit(1);
            }
        }
    }




    // ================================================================================================
    // ==================  Print data on the initial state of the system to file=======================
    // ================================================================================================


    int count_available = 0;
    int count_not_available = 0;
    ofstream crystalFile("Output/crystalline_cellu_bonds.txt");
    for(int i=0;i<nbr_poly_cellu;i++){
        for(int j=0;j<cellu[i].len_poly;j++){
            if(cellu[i].crystalline[j] == true){
                crystalFile << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << endl;
            }
        }
    }
    crystalFile.close();

    ofstream availableFile("Output/available_cellu_bonds.txt");
    for(int i=0;i<nbr_poly_cellu;i++){
        for(int j=0;j<cellu[i].len_poly;j++){
            if(cellu[i].status[j] == 1){
                count_available++;
                availableFile << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << endl;
            }
            else if(cellu[i].status[j] == -1)
                count_not_available++;
            else
                cout << "During initial configutation: bond status is neither -1 nor 1" << endl;
        }
    }
    availableFile.close();
    cout << "available cellu bonds: " << count_available << endl;
    cout << "blocked cellu bonds: " << count_not_available << endl;
    ofstream availableHemiFile("Output/available_hemi_bonds.txt");
    count_available = 0;
    count_not_available = 0;
    for(int i=0;i<nbr_poly_hemi;i++){
        for(int j=0;j<hemi[i].len_poly;j++){
            if(hemi[i].status[j] == 1){
                count_available++;
                availableHemiFile << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
            }
            else if(hemi[i].status[j] == -1){
                count_not_available++;
            }
            else
                cout << "During initial configutation: bond status is neither -1 nor 1" << endl;
        }
    }
    availableHemiFile.close();    
    ofstream HemiFile("Output/available_hemi.txt");
    for(int i=0;i<nbr_poly_hemi;i++){
        for(int j=0;j<hemi[i].len_poly;j++){
                HemiFile << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
        }
    }
	HemiFile.close();    
    ofstream ligninfile("Output/available_lignin_bonds.txt");
    for(int i=0;i<nbr_poly_lign;i++){
    	for(int j=0;j<lign[i].len_poly;j++){
    		ligninfile << lign[i].x << "\t" << lign[i].y << "\t" << lign[i].z[j] << endl;
    	}
    }
    ligninfile.close();
    cout << "available hemi bonds: " << count_available << endl;
    cout << "blocked hemi bonds: " << count_not_available << endl;



    //======================================================================================
    //========================= Add glueing reaction by lignin =============================
    //======================================================================================

    if(par.mode_lignin_glue == 1){
        initTList(Table_lign, 0);
        addreaction(1, Table_lign,0,0,0,5,prop(par,5,chem_entities));
        Table_lign.calcTableProp();
        cout << "Glue reaction prop: " << Table_lign.prop_sum << endl;
    }
    else{
        initTList(Table_lign, 0);
        addreaction(1, Table_lign,0,0,0,5,0);
        Table_lign.prop_sum = 0;
    }

    bond_selected = 0;
    poly_selected = 0;
    nbr_Glc_pdt = 0;
    nbr_xyl_pdt = 0;
    nbr_cellobiose = 0;


    glucoseOverall = countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt;
    xyloseOverall = countXyl(hemi) + nbr_xyl_pdt;
    glcCelluBefore = countGlc(cellu,1);
    glcHemiBefore = countGlc(hemi,2);
    lignolBefore = countLign(lign);
    glcBefore = glcCelluBefore + glcHemiBefore + nbr_Glc_pdt;

    cout << "glucose in whole microfibril: " << glucoseOverall << endl;
    cout << "Number of hemicellulose polymers: " << nbr_poly_hemi << endl;
    cout << "Number of lignin polymers: " << nbr_poly_lign << endl;
    cout << "glucose in hemicellulose: " << countGlc(hemi,2) << endl;
    cout << "xylose in microfibril: " << xyloseOverall << endl;
    cout << "Bonds in cellulose: " << par.length_fibril * nbr_poly_cellu << endl;



    if(verbose == true)
        cout << "a0 in the beginning is equal to " << a0 << endl;

    for(int i=0;i<Table_cellu.size();i++){
        reactionsOverall+=Table_cellu[i].nbr_element;
    }
    for(int i=0;i<Table_hemi.size();i++){
        reactionsOverall+=Table_hemi[i].nbr_element;    
    }

    if(par.length_fibril == 1){ // Check whether the fibril is made only of cellobiose
        nbr_cellobiose = nbr_poly_cellu;
        for(int i=0;i<hemi.size();i++){
        	if(hemi[i].bond_type[0] == 1)
	        	nbr_cellobiose += nbr_poly_hemi;
        }
    }
    else
        nbr_cellobiose = 0;


    if(verbose == true){
        for(int i=0; i<Table_hemi.size();i++){
            for(int j=0;j<Table_hemi[i].nbr_element;j++){
                if(hemi[i].len_poly <= Table_hemi[i].num_bond[j]){
                    cout << "After initialization of hemi: There are some bonds here which are at higher positions than the length of the polymer." << endl;
                    cout << "Poly: " << i << "; len_poly: " << hemi[i].len_poly << "; num_bond: " << Table_hemi[i].num_bond[j] << endl;
                    exit(1);
                }
            }
        }
        a0 = 0;
        for(int i=0; i<Table_hemi.size();i++){
        	a0 += Table_hemi[i].prop_sum;
        }
        for(int i=0;i<Table_cellu.size();i++){
            a0 += Table_cellu[i].prop_sum;

        }
        a0 +=Table_lign.prop_sum;

        if(par.init_XYL > 0 and a0 <= 0){
        	cout << "Initialization of Table_hemi failed!" << endl;
        	exit(1);
        }
        cout << "Initialization of Table_hemi successful" << endl;
    }


    if(verbose == true){
        cout << "inhibition weight factors; EG: " << par.inhib_cellobiose_EG << "; CBH: " << par.inhib_cellobiose_CBH << "; BGL: " << par.inhib_glucose_BGL << endl;
    }
    cout << "Initial number of reactions: " << reactionsOverall << endl;

    

    THRESHOLD=0;
    t0 = 0;


    //==================================== Print some information ==============================================

    cout << "Cellulose percentage: " << 100. * double(glcCelluBefore)/double(glcCelluBefore + xyloseOverall + lignolBefore) << "%" << endl;
    cout << "Hemicellulose percentage: " << 100. * double(xyloseOverall)/double(glcCelluBefore + xyloseOverall + lignolBefore) << "%" << endl;
    cout << "Lignin percentage: " << 100. * double(lignolBefore)/double(glcCelluBefore + xyloseOverall + lignolBefore) << "%" << endl;
    double init_lignin_perc = 100. * double(lignolBefore/(glcCelluBefore + xyloseOverall + lignolBefore));


    //Estimation of  system volume 
    m_fibril = (nbr_poly_cellu * (par.length_fibril+1))*(m_glc);
    m_fibril-= 2*nbr_poly_cellu*m_hydrogen;//Subtract the mass of the hydrogen lost due to bonding of glucose to each other; here for the end of the fibrils
    m_fibril -= 2*(par.length_fibril-2)*nbr_poly_cellu * m_hydrogen;

    double N_fibril = m_dry * (double(nbr_poly_cellu)/double(nbr_poly_cellu+nbr_poly_hemi+nbr_poly_lign)) / m_fibril;

    cout << "m_fibril = " << m_fibril << endl;
    cout << "N_fibril = " << N_fibril << endl;

    V_System = V_solution/(m_dry/m_fibril);
    cout << "Estimated volume of this system: " << V_System << endl;



    cout << "propensity sum at start: " << a0 << endl;




    //============================== Calculate volume density ======================================

    neighborList density_distrib;//For calculating the volume density within a 2D-slice of the microfibril
    int N_checks = 500; //Resolution of density distribution
    double min_x_outer_shell = -2.-2.;
    double max_x_outer_shell = 7.+ 2.;
    double min_y_outer_shell = -1.-2.;
    double max_y_outer_shell = 8.+4.;
    double current_z = 0;
    double current_x = min_x_outer_shell;
    double current_y = min_y_outer_shell;
    double dx = (max_x_outer_shell-min_x_outer_shell)/(double(N_checks)-1.);
    double dy = (max_y_outer_shell-min_y_outer_shell)/(double(N_checks)-1.);
    double R_check = 0.2;
//    double V_check = 4.*M_PI*R_check*R_check*R_check/3.;

//============================== Output density distribution ======================================
/*
    ofstream density_file("Output/density_distrib.txt");
    for(int i=0;i<N_checks;i++){
        cout << "Row " << i << endl;
        current_y = min_y_outer_shell;
        for(int j=0;j<N_checks;j++){
            density_distrib = neighborList(current_x, current_y, current_z, R_check, par, cellu, hemi, lign);
            density_file << current_x << "\t" << current_y << "\t" << 1. - density_distrib.V_free/density_distrib.V_enzyme << endl;
//            cout << density_distrib.V_free << "\t" << density_distrib.V_enzyme << "\t" << density_distrib.N_neighbors << endl;
            current_y += dy;
        }
        current_x += dx;
    }

    density_file.close();
*/

//double x, double y, double z, double V_enzyme, params& par,std::vector<bList>& celluList, std::vector<bList>& hemiList, std::vector<bList>& lignList)





    cout<<"\n \n AVANT GILLESPIE LOOP \n \n"<<endl;

    //======================================================================================
    //============================  START GILLESPIE LOOP ===================================
    //======================================================================================

    vector<int> nbr_reactions;
    par.N_enzymes_glued = 0;

    double reaction_count = 0.;
    while(t0<(par.T+par.Transient))//Max number of steps: par.T + par.Transient. However the simu may (and often will) finish before, for example if there is nothing more to digest
    {
//        cout << par.mode_enzyme_size << endl;
    	if(par.enzyme_timer == 1){
			t_start_gillespie = high_resolution_clock::now(); 		
    	}
    	reaction_count = 0.;
    	for(int i=0;i<Table_cellu.size();i++){
            reaction_count += Table_cellu[i].nbr_element;
    	}
    	for(int i=0;i<Table_hemi.size();i++){
    		reaction_count += Table_hemi[i].nbr_element;
    	}
    	if(reaction_count > 0)
	    	par.Nbr_reactions.push_back(reaction_count);



        //=========================== Take picture of DP distribution
        if(heatmap_bool == 1){
            if(int(t0) % par.DP_print_Freq == 0){

    	    	if(par.enzyme_timer == 1){
    				t_start = high_resolution_clock::now(); 		
    	    	}

                DP_distrib.push_back(DPList(par.length_fibril+1));            

                DP_distrib[DP_index].real_time = real_time;
                DP_distrib[DP_index].DP[0] = nbr_Glc_pdt;

//                count_in_DP = nbr_Glc_pdt;
                for(int i=0; i < cellu.size();i++){
                    DP_len_index = cellu[i].len_poly;//shifted by one to the left due to array placement
                    if(DP_len_index > 0){
                        if(DP_len_index < DP_distrib.at(DP_index).DP.size()){
                            DP_distrib.at(DP_index).DP[DP_len_index] += 1;
  //                      	count_in_DP += DP_len_index+1;
                    	}
                        else
                            cout << "DP_len_index > length_fibril!" << endl;
                    }
                }
//                cout << "According to DP_distrib, there are " << count_in_DP << "glucose units in the system" << endl;
                for(int i=0;i<DP_distrib[DP_index].DP.size();i++){
                	DP_distrib[DP_index].DP[i]*= i+1;
                	DP_distrib[DP_index].DP[i]/=glucoseOverall;
                }

                //chain_length_distribution(cellu, DP_distrib, par.length_fibril, real_time, t0, DP_index);
                DP_index ++;            
            }
        }

        //calculate the overall glucose content of the system before applying the reaction of this step. This is a sanity check to see whether the glucose amount is conserved
        glcBefore = countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt;
        
        countLoops++;
        t0++;

        if(verbose == true){
        	cout << "================================================" << endl;
            cout << "Step number " << t0 << endl;        
            cout << "Glc released before: " << nbr_Glc_pdt << endl;
            cout << "Xyl released before: " << nbr_xyl_pdt << endl;
        }

        //Print progress to command line every printFreq steps
        if(int(t0) % printFreq == 0)
            cout << "Step: " << t0 << "; glc released: " << nbr_Glc_pdt << "; xyl released: " << nbr_xyl_pdt << "; cellobiose in system: " << nbr_cellobiose  << "; real_time: " << real_time << endl;


        if(t0>par.Transient && THRESHOLD==0)
        {
            time_Transient=real_time;//Real transient time
            THRESHOLD=1;
        }

        //Count cellobiose in system and check whether everything is in order
        if(verbose == true){
            if(nbr_cellobiose != countCellobiose(cellu)){
                cout << "nbr_cellobiose != countCellobiose(cellu)!!!!" << endl;
                cout << nbr_cellobiose << "\t" << countCellobiose(cellu)<< endl;
            }
            else
                cout << "nbr_cellobiose = " << countCellobiose(cellu) << endl;
        }


        //=========== Inhibition by glucose and cellobiose ==================        
        if(par.mode_inhib == 1 and (nbr_Glc_pdt > 0 or nbr_cellobiose > 0)){
            update_reactiontables_inhib(Table_cellu, cellu, Table_hemi, par, nbr_Glc_pdt, nbr_cellobiose, chem_entities);
            if(verbose == true)
                cout << "reactions updated" << endl;
        }
        for(int i=0; i<Table_cellu.size();i++)
            Table_cellu[i].calcTableProp();
        for(int i=0; i<Table_hemi.size();i++)
            Table_hemi[i].calcTableProp();

        //========================= Re-calculate propensity sum =========================
        a0=0.;
        a0 +=Table_lign.prop_sum;
        for(int i=0;i<Table_cellu.size();i++)
            a0 += Table_cellu[i].prop_sum;
        for(int i=0;i<Table_hemi.size();i++)
        	a0 += Table_hemi[i].prop_sum;

        if(a0 < 0){
            cout << "In function run(): negative propensity(a0)!!!" << endl;
            exit(1);
        }
        if(verbose == true)
                cout << "a0 = " << a0 << endl;


        //============= Do some checks =============================

        if(a0 == 0 or a0 == Table_lign.prop_sum){//Test whether there are any reactions left in reaction table
            cout << "Nothing more to digest. Stopping. real_time: " << real_time << "; step number: " << t0 << endl;
            cout << "non-cellobiose glucose remaining in fibril: " << countGlc(cellu,1) + countGlc(hemi,2) - 2*countCellobiose(cellu) << endl;

            if(verbose == true){
                for(int i=0; i<cellu.size();i++){
                    for(int j=0; j<cellu[i].len_poly; j++){
                        int neighbor_key = cantor_pair_three(cellu[i].x, cellu[i].y, cellu[i].z[j]);
                        int test10 = 0;
                        for(int k = 0; k < bond_neighbors_cellu[neighbor_key].N_neighbors; k++){
                            if(bond_neighbors_cellu[neighbor_key].scalar_products[k] > 0){
                                test10  = 1;
                            }
                            if(test10 == 0){
                                cout << "Scalar products smaller than or equal to zero, but no status 1 bonds!" << endl;
                                exit(1);
                            }
                        }
                        if(cellu[i].status[j] == 1){
                            cout << "Nothing more to digest, but the status of at least one bond is 1! This should not happen. Stopping" << endl;
                            exit(1);
//                            exit(1);
                        }
                    }
                }
            }
            if (t0 < outputBoundary)
                outputBoundary = t0-1;
            cout << "outputBoundary: " << outputBoundary << "; t0: " << t0 << endl;
            break;
        }


        //======================================================================
        //============== Choose reaction and size of timestep ==================
        //======================================================================


        if(verbose == true)
        	cout << "Choosing reaction" << endl;

        r1 = drand48();//Generates random numbers between 0 and 1
        r2 = drand48();

        tau = 1/a0*(log(1/r1));//Chooses time interval of the next reaction

        real_time += tau;//Update the real time

        if(real_time >= par.max_time){
            cout << "Simulation time ended; glucose released: " << nbr_Glc_pdt << "; xylose released: " << nbr_xyl_pdt << endl;
            return init_lignin_perc;
//            return nbr_Glc_pdt;
        }

    // ============== Choose reaction ======================
        test = r2*a0; //Chooses next reaction to happen
        j=0;



        //======= Choose reaction table ========

        suma = Table_lign.prop_sum;
        if(test <= suma){
            substrate = 0;
            action_mu1 = Table_lign.indic_action[0];
            mu1 = 0;
            poly_selected=Table_lign.index_poly;//Corresponding polymer
            bond_selected=Table_lign.num_bond[0];//Returns the index = position of the bond in the Glc list of thepoly it belongs to
            //substrate=Table_cellu[table_selected].material[mu1];//Corresponding material: 1= cellulose; 2= hemicellulose
        }
        else{
            if(Table_cellu.size() > 0){
            	substrate = 1;
    	        suma += Table_cellu[j].prop_sum; 

    	        while(test>suma)
    	        {
    	            j++;
    	            if(j==Table_cellu.size())
    	                break;
                    if(Table_cellu[j].liste_prop.size()>0)
        	            suma += Table_cellu[j].prop_sum;
    	        }
    	        if(j==Table_cellu.size()){
    	            substrate = 2;
    	            j=0;
    	        }
    	        else
    	            substrate = 1;
    	        if(substrate == 2 and Table_hemi.size()>0){
    	        	j = 0;
    	        	suma +=Table_hemi[0].prop_sum;
    		        while(test>suma){
    		            j++;
                        if(Table_hemi[j].liste_prop.size()>0)
        		            suma += Table_hemi[j].prop_sum;
    		        }

    	        }

    	        table_selected = j;

    		}
    		else if(Table_hemi.size() > 0){
    			substrate = 2;
                if(Table_hemi[j].liste_prop.size()>0)
        			suma += Table_hemi[j].prop_sum;
                else
                    suma = Table_lign.prop_sum;

    			while(test > suma){
    				j++;
                    if(Table_hemi[j].liste_prop.size()>0)
        				suma += Table_hemi[j].prop_sum;
    			}
    			table_selected = j;
    		}
    		else {
    			cout << "Reaction table empty. Stopping." << endl;
                return init_lignin_perc;
//    			return nbr_Glc_pdt;
    		}
    		if(verbose == true)
    			cout << "table_selected: " << table_selected << endl;
            //============ Choose reaction within chosen table ========

            if(substrate == 1){
            	if(verbose == true)
            		cout << "substrate = 1" << endl;        	
                mu1 = findIndex(Table_cellu[table_selected], suma, test);//Index of the reaction chosen
                if(mu1 == -1){
                	cout << "empty reaction table selected! there is a problem! Stopping. Substrate: " << substrate << endl;
                	exit(1);
            	}            
                poly_selected=Table_cellu[table_selected].index_poly;//Corresponding polymer
                bond_selected=Table_cellu[table_selected].num_bond[mu1];//Returns the index = position of the bond in the Glc list of thepoly it belongs to
                //substrate=Table_cellu[table_selected].material[mu1];//Corresponding material: 1= cellulose; 2= hemicellulose
                action_mu1=Table_cellu[table_selected].indic_action[mu1];//Corresponding reaction
            }
            else if(substrate == 2){
            	if(verbose == true)
            		cout << "substrate = 2" << endl;
                mu1 = findIndex(Table_hemi[table_selected], suma, test);//Index of the reaction chosen
                if(verbose == true){
                    cout << "found index" << endl;
                }
                if(mu1 == -1){
                	cout << "empty reaction table selected! there is a problem! Stopping. Substrate: " << substrate << endl;
                	exit(1);
                }
                poly_selected=Table_hemi[table_selected].index_poly;//Corresponding polymer
                bond_selected=Table_hemi[table_selected].num_bond[mu1];//Returns the index = position of the bond in the Glc list of thepoly it belongs to
                //substrate=Table_hemi[table_selected].material[mu1];//Corresponding material: 1= cellulose; 2= hemicellulose
                action_mu1=Table_hemi[table_selected].indic_action[mu1];//Corresponding reaction            

            }
            else if(substrate != 1 and substrate != 2)
                cout << "Something is going wrong in the selection of the reaction. substrate is neither cellu nor hemi!" << endl;

        }



        if(par.enzyme_timer == 1){
			t_end = high_resolution_clock::now();
			duration = duration_cast<microseconds>(t_end - t_start);
			time_find_reaction.push_back(double(duration.count()));
        }


        if(verbose == true){
        	if(substrate == 1){
            cout << "poly_selected: " << poly_selected << "; table_selected: " << table_selected << "; its size: " << Table_cellu[table_selected].nbr_element << " or " << Table_cellu[table_selected].liste_prop.size() << "; bond_selected: " << bond_selected << "; Length of polymer: " << cellu[poly_selected].len_poly << endl;
            cout << "enzyme: " << action_mu1 << "; substrate: " << substrate << "; Number of cellu polymers: " << cellu.size() << "; Number of associated reaction tables: " << Table_cellu.size() << "; propensity: " << Table_cellu[table_selected].liste_prop[mu1] << endl;
            }
            else if(substrate ==2){
	            cout << "poly_selected: " << poly_selected << "; table_selected: " << table_selected << "; its size: " << Table_hemi[table_selected].nbr_element << " or " << Table_hemi[table_selected].liste_prop.size() << "; bond_selected: " << bond_selected << "; Length of polymer: " << hemi[poly_selected].len_poly << endl;
    	        cout << "enzyme: " << action_mu1 << "; substrate: " << substrate << "; Number of hemi polymers: " << hemi.size() << "; Number of associated reaction tables: " << Table_hemi.size() << endl;
            }
            else if(substrate == 0){
                cout << "glue!" << endl;
            }
            if(substrate == 1){
	            for(int i=0;i<Table_cellu[table_selected].nbr_element; i++){
	                if(Table_cellu[table_selected].indic_action[i] == 1 and par.init_EG == 0)
	                    cout << "EG digest action even though there is no EG in system" << endl;

	            }
            }
        }



        if(verbose == true){
        	if(substrate == 1)
	            cout << "reactions connected to this polymer: " << countReactions(Table_cellu[table_selected], poly_selected, error_bool) << endl;
	        else if(substrate == 2)
	        	cout << "reactions connected to this polymer: " << countReactions(Table_hemi[table_selected], poly_selected, error_bool) << endl;

	        if(error_bool == 1)
	        	exit(1);
    }

    //=================================== Some more checking and optional printed information ====================
    if(verbose == true){
    	if(substrate ==1){
	    	if(cellu[poly_selected].len_poly == 1){ 
		        cout << "=======================================" << endl;
		        cout << "len_poly = 1; prop_sum = " << Table_cellu[poly_selected].prop_sum << "; number of reactions: " << Table_cellu[poly_selected].liste_prop.size() << "\t" << Table_cellu[poly_selected].prop_uninhib.size() << "\t"\
		         << "\t" << Table_cellu[poly_selected].liste_prop.size() << endl;
		        cout << Table_cellu[poly_selected].nbr_element << endl;
		         for(int o = 0; o<Table_cellu[poly_selected].indic_action.size();o++){
		            cout << Table_cellu[poly_selected].index_poly << "\t" \
		                << Table_cellu[poly_selected].num_bond[o] << "\t" \
		                << Table_cellu[poly_selected].material[o] << "\t" \
		                << Table_cellu[poly_selected].indic_action[o] << "\t" \
		                << Table_cellu[poly_selected].liste_prop[o] << "\t" \
		                << Table_cellu[poly_selected].prop_uninhib[o] << endl;
		            }
		        cout << "=======================================" << endl;
	    	}
	    }
     }


        //=================== Take picture of the whole system =========================
        glcBefore = countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt;
        if(sim_number != 0){

            if(t0<= par.T + par.Transient and int(t0)%par.pict_3D_Freq == 0)
            {
                // ================= 3D structure snapshot ===================
                if(vid == true and sim_number == 1){
                    memset(par.output_file, 0, sizeof(par.output_file));
                    strcat(par.output_file, "Output/3D/");                    
                    strcat(par.output_file, "bond_neighbor_visualization_cellu_");
                    strcat(par.output_file, par.str5);
                    strcat(par.output_file, "_");
                    sprintf(par.str,"%d",nbr_pict_taken);
                    strcat(par.output_file, par.str);
                    strcat(par.output_file, ".txt");
        
                    ofstream bond_neighbor_heatmap(par.output_file);
                    int current_key = 0;
                    for(int i=0; i<cellu.size(); i++){
                        for(int j=0; j<cellu[i].z.size(); j++){
                            current_key = cantor_pair_three(cellu[i].x,cellu[i].y,cellu[i].z[j]);
//                            cout << "(" << cellu[i].x << ", " << cellu[i].y << ", " << cellu[i].z[j] << "): " << bond_neighbors_cellu[current_key].N_neighbors << endl;
                            bond_neighbor_heatmap << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << "\t" << bond_neighbors_cellu[current_key].N_neighbors << endl;
                        }
                        bond_neighbor_heatmap << "\n" << endl;
                    }
                    bond_neighbor_heatmap.close();



                    //Builds the visualization ouput file of the fibril
                    memset(par.output_file, 0, sizeof(par.output_file));
                    strcat(par.output_file, "Output/3D/");                    
                    strcat(par.output_file, "visualisation_fibril_");
                    strcat(par.output_file, par.str5);
                    strcat(par.output_file, "_");
                    sprintf(par.str,"%d",nbr_pict_taken);
                    strcat(par.output_file, par.str);
                    strcat(par.output_file, ".txt");
                    ofstream file52(par.output_file,ios::app);
                    cout << par.output_file << endl;
                    //Output the structure of remaining cellulose
                    for(int i=0; i<nbr_poly_cellu; i++)
                    {
                        for(int j=0; j<cellu[i].len_poly; j++)
                        {
                            if((cellu[i].status[j]==-1) or(cellu[i].status[j]==1))
                                file52<<cellu[i].x<<'\t'<<cellu[i].y<<'\t'<<cellu[i].z[j]<<'\t'<<cellu[i].index<<endl;
                        }
                    }


                    //Builds the visualization ouput file of ALL hemicellulose
                    if(nbr_poly_hemi > 0){
                        memset(par.output_file, 0, sizeof(par.output_file));
                        strcat(par.output_file, "Output/3D/");                    
                        strcat(par.output_file, "visualisation_hemi_");
                        strcat(par.output_file, par.str5);
                        strcat(par.output_file, "_");
                        sprintf(par.str,"%d",nbr_pict_taken);
                        strcat(par.output_file, par.str);
                        strcat(par.output_file, ".txt");
                        ofstream file62(par.output_file,ios::app);
                        cout << par.output_file << endl;
                        //Output the structure of all hemicellulose
                        for(int i=0; i<nbr_poly_hemi; i++)
                        {
                            for(int j=0; j<hemi[i].len_poly; j++)
                                file62<<hemi[i].x<<'\t'<<hemi[i].y<<'\t'<<hemi[i].z[j]<<endl;
                        }
                    }

                    if(nbr_poly_hemi > 0){
                    //Builds the visualization ouput file of hemicellulose acetylated
                        memset(par.output_file, 0, sizeof(par.output_file));
                        strcat(par.output_file, "Output/3D/");
                        strcat(par.output_file, "visualisation_hemi_acetylated_");
                        strcat(par.output_file, par.str5);
                        strcat(par.output_file, "_");
                        sprintf(par.str,"%d",nbr_pict_taken);
                        strcat(par.output_file, par.str);
                        strcat(par.output_file, ".txt");
                        ofstream file72(par.output_file,ios::app);
                        cout << par.output_file << endl;
                        //Output the structure of hemicellulose acetylated
                        for(int i=0; i<nbr_poly_hemi; i++)
                        {
                            for(int j=0; j<hemi[i].len_poly; j++)
                            {
                                if(hemi[i].status[j]==-2)
                                    file72<<hemi[i].x<<'\t'<<hemi[i].y<<'\t'<<hemi[i].z[j]<<endl;
                            }
                        }
                    }
                    cout << nbr_poly_lign << endl;
                    if(nbr_poly_lign > 0){
                        cout << "lign building" << endl; 
                    //Builds the visualization ouput file of lignin
                        memset(par.output_file, 0, sizeof(par.output_file));
                        strcat(par.output_file, "Output/3D/");
                        strcat(par.output_file, "visualisation_lignin_");
                        strcat(par.output_file, par.str5);
                        strcat(par.output_file, "_");
                        sprintf(par.str,"%d",nbr_pict_taken);
                        strcat(par.output_file, par.str);
                        strcat(par.output_file, ".txt");
                        ofstream file82(par.output_file,ios::app);
                        cout << par.output_file << endl;
                        //Output the structure of lignin
                        for(int i=0; i<nbr_poly_lign; i++)
                        {
                            for(int j=0; j<lign[i].len_poly; j++)
                                file82<<lign[i].x<<'\t'<<lign[i].y<<'\t'<<lign[i].z[j]<<endl;
                        }
                    }

                    nbr_pict_taken++;

        
                }
            }
        }        


    //Save output data for this step
    par.amount_glc_mean.push_back(100. * nbr_Glc_pdt /(nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)));//glucan to glucose percentage
    par.amount_cellobiose_mean.push_back(100 * 2 * nbr_cellobiose/(nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)));//percentage of glucose in cellobiose
    par.amount_xylose_mean.push_back(100 * nbr_xyl_pdt/(nbr_xyl_pdt + countXyl(hemi)));
    par.EG_conc_mean.push_back(chem_entities[0]);
    par.CBH_conc_mean.push_back(chem_entities[1]);
    par.BGL_conc_mean.push_back(chem_entities[2]);
    par.XYL_conc_mean.push_back(chem_entities[3]);
    par.enzymes_glued.push_back(par.N_enzymes_glued);
    par.time_mean.push_back(real_time);

    if(t0>0){

    	par.EG_activity.push_back(double(count_EG)/double(t0));
    	par.CBH_activity.push_back(double(count_CBH)/double(t0));
    	par.BGL_activity.push_back(double(count_BGL)/double(t0));
    	par.XYL_activity.push_back(double(count_xylanase)/double(t0));
        par.lign_activity.push_back(double(count_lignin_glue)/double(t0));

    }
    if(int(t0) % enzyme_activity_Freq == 0)
        check_reaction_table_distribution(Table_cellu,Table_hemi,Table_lign, par);






        if (substrate == 1)//check length of polymer at the start of the step
            len_polyLoopStart = cellu[poly_selected].len_poly;
        if (substrate == 2)
            len_polyLoopStart = hemi[poly_selected].len_poly;
        

        //Sanity checks
        if(substrate == 1 and action_mu1 != 5){
            x_selected = cellu[poly_selected].x;
            y_selected = cellu[poly_selected].y;
            z_selected = cellu[poly_selected].z[bond_selected];
            if (cellu[poly_selected].crystalline[bond_selected] == true and par.crystal_modifier_cellu == 0){
                cout << "A CRYSTALLINE CELLU BOND IS BEING DIGESTED EVEN THOUGH THE WEIGHT FACTOR IS 0. ABORTING" << endl;
                exit(1);
            }
        }
        else if(substrate == 2 and action_mu1 != 5){
            x_selected = hemi[poly_selected].x;
            y_selected = hemi[poly_selected].y;
            z_selected = hemi[poly_selected].z[bond_selected];
            if (hemi[poly_selected].crystalline[bond_selected] == true and par.crystal_modifier_hemi == 0){
                cout << "A CRYSTALLINE HEMI BOND IS BEING DIGESTED EVEN THOUGH THE WEIGHT FACTOR IS 0. ABORTING" << endl;
                exit(1);
            }
        }
        //=====================================================================================================
        //==================================== Perform the digestion or glueing reaction =======================
        //=====================================================================================================





        //=========================================================================================
        //==============================  Digestion by EG  ========================================
        //=========================================================================================
        if(action_mu1 != 1 and par.init_CBH == 0 and par.init_BGL == 0 and par.init_XYL == 0){
            cout << "action_mu1: " << action_mu1 << endl;
            cout << "There is only EG in the system, but a non_EG reaction was selected. Stopping..." << endl;
            exit(1);
        }

        if(action_mu1==1)
        {
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now();
        	}        	
            count_EG++;
            if(verbose == true)
                cout << "EG" << endl;

            /*If the material digested is cellulose*/ 
            if(substrate == 1){
                if(bond_selected == 1 or bond_selected == cellu[poly_selected].len_poly-2)
                    cout << "EG digest: bond number" << bond_selected << "; poly length: " << cellu[poly_selected].len_poly << endl;
                EG_digest(par, Table_cellu, cellu, nbr_poly_cellu, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose,error_bool);
            }
            else if(substrate == 2)//This may happen later, when hemicellulose is updated to include sugars other than xylose
                EG_digest(par, Table_hemi, hemi, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);

            if(error_bool == 1){
            	cout << "Error detected in function EG_digest. Stopping" << endl;
            	exit(1);
            }
            if(par.enzyme_timer == 1){
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_EG.push_back(double(duration.count()));
            }            
        }


        //=========================================================================================
        //==============================  Digestion by CBH  =======================================
        //=========================================================================================

        if(action_mu1==2)
        {
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now(); 		
        	}        	
            count_CBH++;
            if(verbose == true)
                cout << "CBH" << endl;

            if(substrate == 1)
                CBH_digest(par, Table_cellu, cellu, nbr_poly_cellu, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            else if(substrate == 2)
                CBH_digest(par, Table_hemi, hemi, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);

            if(error_bool == 1){
            	cout << "Error detected in function CBH_digest. Stopping" << endl;
            	exit(1);
            }
            if(par.enzyme_timer == 1){
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_CBH.push_back(double(duration.count()));
            }            
        }




        //=========================================================================================
        //==============================  Digestion by BGL  =======================================
        //=========================================================================================

        if(action_mu1==3)
        {
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now(); 		
        	}
            count_BGL++;
            if(verbose == true)
                cout << "BGL" << endl;

            if(substrate == 1)
                BGL_digest(par, Table_cellu, cellu, nbr_poly_cellu, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            else if(substrate == 2)
                BGL_digest(par, Table_hemi, hemi, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);

            if(error_bool == 1){
            	cout << "Error detected in function BGL_digest. Stopping" << endl;
            	exit(1);
            }
            if(par.enzyme_timer == 1){
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_BGL.push_back(double(duration.count()));
            }

        }

        //=========================================================================================
        //==============================  Digestion by XYL  =======================================
        //=========================================================================================


        if(action_mu1 == 4){
        	if(par.enzyme_timer == 1){
				t_start = high_resolution_clock::now(); 		
        	}        	
            count_xylanase++;        	
        	if(verbose == true){
        		cout << "XYL" << endl;
            }

            if(verbose == true){
                int count_xyl_before = countXyl(hemi) + nbr_xyl_pdt;
                XYL_digest(par, Table_hemi, Table_cellu, hemi, cellu, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
                if(count_xyl_before != countXyl(hemi) + nbr_xyl_pdt){
                    cout << "In function XYL_digest: xylose number is not conserved. Stopping." << endl;
                    exit(1);
                }
            }
            else{
            	XYL_digest(par, Table_hemi, Table_cellu, hemi, cellu, nbr_poly_hemi, nbr_xyl_pdt, nbr_Glc_pdt, bond_selected, poly_selected, len_polyLoopStart,nbr_cellobiose,chem_entities,substrate,bond_neighbors_cellu,bond_neighbors_hemi,verbose, error_bool);
            }
        	
        	if(error_bool == 1){
        		cout << "Error detected in function XYL_digest. Stopping" << endl;
        		exit(1);
        	}
            if(par.enzyme_timer == 1){
				t_end = high_resolution_clock::now();
				duration = duration_cast<microseconds>(t_end - t_start);
				time_XYL.push_back(double(duration.count()));
            }        	
        }

        if(action_mu1 != 5 and par.mode_enzyme_size == 1){
            if(verbose == true){
                cout << "Updating reaction table" << endl;
            }
            update_reactiontables(cellu, hemi, lign, Table_cellu, Table_hemi, par, chem_entities, bond_neighbors_cellu, bond_neighbors_hemi, x_selected, y_selected, z_selected, substrate, poly_selected, bond_selected);
        }
        //=========================================================================================
        //==============================  Glueing by lignin  =======================================
        //=========================================================================================

        if(par.mode_lignin_glue == 1){
            if(action_mu1 == 5){
                count_lignin_glue++;
                lignin_glue(par, Table_cellu, Table_hemi,Table_lign, chem_entities, nbr_poly_lign);

            }
        }


        if(verbose == true){
            cout << "Getting past digest" << endl;
            cout << "Glc released now: " << nbr_Glc_pdt << endl;            
            cout << "Sizes of neighbor tables: cellu: " << bond_neighbors_cellu.size() << "; hemi: " << bond_neighbors_hemi.size() << endl; 
        }


        if (countGlc(cellu,1) + countGlc(hemi,2) + nbr_Glc_pdt != glcBefore){
            cout << "Glucose produced or consumed in a reaction of action_mu1 " << action_mu1 << ", polymer " << poly_selected << ", its length(cellu): " << len_polyLoopStart << ", and after digest: " << cellu[poly_selected].len_poly << ", substrate: " << substrate << endl;
            cout << "Bond selected: " << bond_selected << ", Loop number: " << countLoops << endl;
            exit(1);
        }



        //======================= Check, whether a polymer has been completely digested, and if yes, erase the corresponding object

        if(substrate == 1){
            if(cellu[poly_selected].len_poly == 0){
                cellu.erase(cellu.begin()+poly_selected);
                Table_cellu.erase(Table_cellu.begin()+poly_selected);
                nbr_poly_cellu--;
                if(poly_selected < Table_cellu.size()){
                    for(int i=poly_selected; i< cellu.size();i++){//this iterates through cellu and Table_cellu, because they have the same size
                        cellu[i].index = i;
                        Table_cellu[i].index_poly = i;

                    }

                }
            }
        }
        else if(substrate == 2){
            if(hemi[poly_selected].len_poly == 0){
                hemi.erase(hemi.begin()+poly_selected);
                Table_hemi.erase(Table_hemi.begin()+poly_selected);
                nbr_poly_hemi--;
                if(poly_selected < Table_hemi.size()){
                    for(int i=poly_selected; i < hemi.size();i++){//this iterates through hemi and Table_hemi, because they have the same size
                        hemi[i].index = i;
                        Table_hemi[i].index_poly = i;
                    }
                }
            }

        }
        if(par.enzyme_timer == 1){
			t_end_gillespie = high_resolution_clock::now();
			duration = duration_cast<microseconds>(t_end_gillespie - t_start_gillespie);
			time_per_gillespie_step.push_back(double(duration.count()));
        }
/*
        for(int i=0;i<Table_cellu.size();i++){
            Table_cellu[i].liste_prop.clear();
            Table_cellu[i].num_bond.clear();
            Table_cellu[i].material.clear();
            Table_cellu[i].indic_action.clear();
            Table_cellu[i].liste_prop.clear();

            Table_cellu[i].prop_sum = 0;
            Table_cellu[i].nbr_element = 0;
            fill_table(par, Table_cellu, cellu, i, 1, error_bool, chem_entities);
        }
        for(int i=0;i<Table_hemi.size();i++){
            Table_hemi[i].liste_prop.clear();
            Table_hemi[i].num_bond.clear();
            Table_hemi[i].material.clear();
            Table_hemi[i].indic_action.clear();
            Table_hemi[i].liste_prop.clear();

            Table_hemi[i].prop_sum = 0;
            Table_hemi[i].nbr_element = 0;
            fill_table(par, Table_hemi, hemi, i, 2, error_bool, chem_entities);
        }*/

    //=======================================================================================
    //=============== END of the Gillespie loop =============================================
    //=======================================================================================
    }

    if(verbose == true){
        cout << "At the end of the loop: glucose left in fibril: " << countGlc(cellu, 1) << "; xylose left in firbil: " << countXyl(hemi) << endl;
    }

    ofstream end_cellu_File("Output/end_cellu_bonds.txt");
    for(int i=0;i<nbr_poly_cellu;i++){
        for(int j=0;j<cellu[i].len_poly;j++){
            end_cellu_File << cellu[i].x << "\t" << cellu[i].y << "\t" << cellu[i].z[j] << endl;
        }
    }
    end_cellu_File.close();

    ofstream end_Hemi_File("Output/end_hemi_bonds.txt");

    for(int i=0;i<nbr_poly_hemi;i++){
        for(int j=0;j<hemi[i].len_poly;j++){
            end_Hemi_File << hemi[i].x << "\t" << hemi[i].y << "\t" << hemi[i].z[j] << endl;
        }
    }
    end_Hemi_File.close();    
    ofstream end_lign_file("Output/end_lignin_bonds.txt");
    for(int i=0;i<nbr_poly_lign;i++){
        for(int j=0;j<lign[i].len_poly;j++){
            end_lign_file << lign[i].x << "\t" << lign[i].y << "\t" << lign[i].z[j] << endl;
        }
    }
    end_lign_file.close();


//========================= Calculate average time taken for each enzyme function =================================
	if(par.enzyme_timer == 1){
		double mean_time;
		if(time_EG.size()>0){
			mean_time = 0;
			ofstream EG_timer_file("Output/time_EG.txt");
			for(int i=0;i<time_EG.size();i++){
				mean_time += time_EG[i]/double(time_EG.size());
				EG_timer_file << i << "\t" << time_EG[i] << endl;
			}
			EG_timer_file.close();
			cout << "Average time taken by function EG_digest: " << mean_time << " microseconds" << endl;
		}
		if(time_CBH.size()>0){
			mean_time = 0;
			ofstream CBH_timer_file("Output/time_CBH.txt");
			for(int i=0;i<time_CBH.size();i++){
				mean_time += time_CBH[i]/double(time_CBH.size());
				CBH_timer_file << i << "\t" << time_CBH[i] << endl;
			}
			CBH_timer_file.close();
			cout << "Average time taken by function CBH_digest: " << mean_time << " microseconds" << endl;			
		}
		if(time_BGL.size()>0){
			mean_time = 0;
			ofstream BGL_timer_file("Output/time_BGL.txt");
			for(int i=0;i<time_BGL.size();i++){
				mean_time += time_BGL[i]/double(time_BGL.size());
				BGL_timer_file << i << "\t" << time_BGL[i] << endl;
			}
			BGL_timer_file.close();
			cout << "Average time taken by function BGL_digest: " << mean_time << " microseconds" << endl;			
		}
		if(time_XYL.size()>0){
			mean_time = 0;
			ofstream XYL_timer_file("Output/time_XYL.txt");
			for(int i=0;i<time_XYL.size();i++){
				mean_time += time_XYL[i]/double(time_XYL.size());
				XYL_timer_file << i << "\t" << time_XYL[i] << endl;
			}
			XYL_timer_file.close();
			cout << "Average time taken by function XYL_digest: " << mean_time << " microseconds" << endl;			
		}
		if(time_find_reaction.size()>0){
			mean_time = 0;
			ofstream find_reaction_timer_file("Output/time_find_reaction.txt");
			for(int i=0;i<time_find_reaction.size();i++){
				mean_time += time_find_reaction[i]/double(time_find_reaction.size());
				find_reaction_timer_file << i << "\t" << time_find_reaction[i] << endl;
			}
			find_reaction_timer_file.close();
			cout << "Average time taken to find a reaction inside the table: " << mean_time << " microseconds" << endl;			
		}		
		if(time_per_gillespie_step.size()>0){
			mean_time = 0;
			ofstream time_per_gillespie_step_timer_file("Output/time_per_gillespie_step.txt");
			for(int i=0;i<time_per_gillespie_step.size();i++){
				mean_time += time_per_gillespie_step[i]/double(time_per_gillespie_step.size());
				time_per_gillespie_step_timer_file << i << "\t" << time_per_gillespie_step[i] << endl;
			}
			time_per_gillespie_step_timer_file.close();
			cout << "Average time taken per gillespie step: " << mean_time << " microseconds" << endl;			
		}		
	}

    //============================================================
	//==================== Wrap up ===============================
    //============================================================
    cout << "t=   " << real_time << endl;
    if(verbose == true)
        cout << "Glucose in cellu: " << countGlc(cellu,1) << "; glucose in hemi: " << countGlc(hemi,2) << "; xylose in hemi: " << countXyl(hemi) << "; glucose relased: " << nbr_Glc_pdt << "; xylose released: " << nbr_xyl_pdt << endl;
 
    //Check again whether the glucose amount is conserved
    if(glucoseOverall - (nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)) == 0 and xyloseOverall - (nbr_xyl_pdt + countXyl(hemi)) == 0){
        cout << "==== Everything appears to be working; glucose produced: " << nbr_Glc_pdt << "; xylose produced: " << nbr_xyl_pdt << " ====" << endl;
    }
    else{
        if(glucoseOverall - (nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2)) != 0 and xyloseOverall - (nbr_xyl_pdt + countXyl(hemi)) != 0){
            cout << "WE ARE EITHER LOSING MONOMERS OR PRODUCING THEM FROM NOTHING!" << endl;
            exit(1);
        }
        else if(xyloseOverall - (nbr_xyl_pdt + countXyl(hemi)) != 0){
            cout << "WE ARE EITHER LOSING XYLOSE OR PRODUCING IT FROM NOTHING!" << endl;
            exit(1);
        }
        else if(nbr_Glc_pdt + countGlc(cellu,1) + countGlc(hemi,2) != 0){
            cout << "WE ARE EITHER LOSING XYLOSE OR PRODUCING IT FROM NOTHING!" << endl;
            exit(1);
        }
    }

    printf("DONE!\n");
//    drawPolys(cellu);

    if(verbose == true){
        cout << "Before clearing the neighbor maps, their sizes are: cellu: " << bond_neighbors_cellu.size() << "; hemi: " << bond_neighbors_hemi.size() << endl;
    }

    bond_neighbors_cellu.clear();
    bond_neighbors_hemi.clear();
    nbr_poly_cellu = 0;
    nbr_poly_hemi = 0;
    nbr_poly_lign = 0;


    cout << "Final glucose in system: " << nbr_Glc_pdt << "; final cellobiose in system: " << nbr_cellobiose << "; final xylose in system: " << nbr_xyl_pdt << endl;





    return nbr_Glc_pdt;//Returns the number of glucose monomers released from the microfibril at the end of the simulation


    //END OF FUNCTION
}